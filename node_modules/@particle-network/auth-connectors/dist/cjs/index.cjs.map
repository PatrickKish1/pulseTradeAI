{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/store.ts", "../../src/getClient.ts", "../../src/getConnection.ts", "../../src/particleEvm.ts", "../../src/particleSolana.ts", "../../src/types.ts", "../../src/version.ts"],
  "sourcesContent": ["export * from './store';\nexport * from './types';\nexport * from './version';\n", "import { AuthType } from '@particle-network/auth-core';\nimport { AuthCoreContextProvider, type AuthCoreModalOptions, type CustomStyle } from '@particle-network/authkit';\nimport {\n  ChainNotConfiguredError,\n  createEmitter,\n  createWalletConnector,\n  isEVMChain,\n  isSolanaChain,\n  type ChainType,\n  type ClientType,\n  type Connector,\n  type ConnectorEventMap,\n  type CreateConnectorFn,\n  type EVMChain,\n  type Prettify,\n  type WalletConnectorsOption,\n} from '@particle-network/connector-core';\nimport { createStore } from 'zustand/vanilla';\nimport { getPublicClient } from './getClient';\nimport { getConnection } from './getConnection';\nimport { particleEvm } from './particleEvm';\nimport { particleSolana } from './particleSolana';\nimport { auth } from './types';\n\ntype AuthConnectorsOption = WalletConnectorsOption & {\n  projectId: string;\n  clientKey: string;\n  appId: string;\n};\n\ntype AuthTypeValue = `${AuthType}`;\n\nexport type AuthWalletParameters = Prettify<\n  Pick<AuthCoreModalOptions, 'language' | 'fiatCoin' | 'promptSettingConfig'> & {\n    authTypes?: (AuthTypeValue | AuthType)[];\n    overrides?: {\n      customStyle?: CustomStyle;\n    };\n  }\n>;\n\nauthWalletConnectors.type = 'particleAuth' as const;\nexport function authWalletConnectors(parameters: AuthWalletParameters = {}) {\n  const { authTypes, fiatCoin, promptSettingConfig, overrides, language } = parameters;\n  if (authTypes && authTypes.length === 0) {\n    throw new Error('authTypes cannot be empty.');\n  }\n  type Properties = {\n    authOptions: AuthCoreModalOptions;\n    supportAuthTypes: readonly [AuthType, ...AuthType[]];\n    AuthCoreContextProvider: (props: { options: AuthCoreModalOptions; children: React.ReactNode }) => React.JSX.Element;\n  } & { auth: typeof auth };\n\n  const supportAuthTypes = (authTypes as AuthType[]) || Object.values(AuthType);\n\n  return createWalletConnector<AuthConnectorsOption, Properties>((options) => {\n    const { chains: _chains, storage, projectId, clientKey, appId } = options;\n    const chains = createStore(() => _chains);\n\n    function setup(connectorFn: CreateConnectorFn): Connector {\n      // Set up emitter and add to connector so they are \"linked\" together.\n      const emitter = createEmitter<ConnectorEventMap>();\n      const result = connectorFn({ emitter, chains: _chains, storage });\n      const connector = {\n        ...result,\n        emitter,\n        uid: emitter.uid,\n        chainType: result.id.toLowerCase().includes('evm') ? ('evm' as const) : ('solana' as const),\n        walletConnectorType: authWalletConnectors.type,\n      };\n      connector.setup?.();\n      return connector;\n    }\n\n    const storeData: CreateConnectorFn[] = [];\n    if (_chains.some(isEVMChain)) {\n      storeData.push(particleEvm());\n    }\n    if (_chains.some(isSolanaChain)) {\n      storeData.push(particleSolana());\n    }\n\n    const connectors = createStore(() => storeData.map(setup));\n\n    function getClient<chainType extends ChainType = EVMChain>(chainId: number): ClientType<chainType> {\n      const chain = chains.getState().find((chain) => chain.id === chainId);\n      if (!chain) {\n        throw new ChainNotConfiguredError();\n      }\n      if (isEVMChain(chain)) {\n        return getPublicClient(chain) as ClientType<chainType>;\n      }\n\n      return getConnection(chain) as ClientType<chainType>;\n    }\n\n    return {\n      get type() {\n        return authWalletConnectors.type;\n      },\n      get chains() {\n        return chains.getState();\n      },\n      get connectors() {\n        return connectors.getState();\n      },\n      store: connectors,\n      getClient,\n      supportAuthTypes: supportAuthTypes as unknown as readonly [AuthType, ...AuthType[]],\n      authOptions: {\n        projectId,\n        clientKey,\n        appId,\n        authTypes: supportAuthTypes,\n        fiatCoin,\n        language,\n        promptSettingConfig,\n        supportEIP6963: false,\n        customStyle: {\n          zIndex: 2147500000,\n          ...overrides?.customStyle,\n        },\n        wallet: false,\n        chains: _chains,\n      },\n      AuthCoreContextProvider,\n      _internal: {\n        connectors: {\n          setup,\n        },\n      },\n      auth,\n    };\n  });\n}\n", "import { createPublicClient, http, type Chain, type PublicClient } from 'viem';\n\nconst clients = new Map<number, PublicClient>();\n\nexport function getPublicClient(chain: Chain): PublicClient {\n  {\n    const client = clients.get(chain.id);\n    if (client) return client;\n  }\n\n  const client = createPublicClient({\n    chain,\n    transport: http(),\n  });\n  clients.set(chain.id, client);\n\n  return client;\n}\n", "import { Connection, type Commitment, type ConnectionConfig } from '@solana/web3.js';\nimport type { Chain } from 'viem';\n\nconst clients = new Map<number, Connection>();\n\nexport function getConnection(chain: Chain, commitmentOrConfig?: Commitment | ConnectionConfig): Connection {\n  {\n    const client = clients.get(chain.id);\n    if (client) return client;\n  }\n\n  const client = new Connection(chain.rpcUrls.default.http[0]!, commitmentOrConfig);\n\n  clients.set(chain.id, client);\n\n  return client;\n}\n", "import type {\n  ConnectParam,\n  ConnectWithEmailParam,\n  ConnectWithPhoneParam,\n  ConnectWithProvider,\n} from '@particle-network/auth-core';\nimport {\n  ChainNotConfiguredError,\n  ProviderNotFoundError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  createConnector,\n  isEVMChain,\n  numberToHex,\n  type Connector,\n  type RpcError,\n} from '@particle-network/connector-core';\nimport { type EVMProvider } from './types';\n\ntype ConnectOptions = Omit<ConnectParam, 'chain'> & { chainId?: number; isReconnecting?: boolean };\n\nparticleEvm.type = 'particleAuth' as const;\nexport function particleEvm() {\n  type Provider = EVMProvider | undefined;\n\n  type Properties = {\n    connect(options?: ConnectOptions): Promise<{\n      accounts: readonly string[];\n      chainId: number;\n    }>;\n  };\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined;\n  let chainChanged: Connector['onChainChanged'] | undefined;\n  let disconnect: Connector['onDisconnect'] | undefined;\n\n  return createConnector<Provider, Properties>((config) => ({\n    get icon() {\n      return 'https://static.particle.network/logo-small.png';\n    },\n    get id() {\n      return 'particleEVM';\n    },\n    get name() {\n      return 'Particle Auth';\n    },\n    type: particleEvm.type,\n    async connect(options: ConnectOptions) {\n      const { chainId, isReconnecting } = options;\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      if ((options as ConnectWithPhoneParam).phone && !(options as ConnectWithPhoneParam).code) {\n        throw new Error('Paramers error, need code.');\n      }\n\n      if ((options as ConnectWithEmailParam).email && !(options as ConnectWithEmailParam).code) {\n        throw new Error('Paramers error, need code.');\n      }\n\n      if ((options as ConnectWithProvider).provider && !(options as ConnectWithProvider).thirdpartyCode) {\n        throw new Error('Paramers error, need thirdpartyCode.');\n      }\n\n      let accounts: readonly string[] = [];\n      accounts = await this.getAccounts().catch(() => []);\n\n      try {\n        if (!accounts?.length && !isReconnecting) {\n          accounts = await provider.connect({\n            ...options,\n            chain: chainId ? config.chains.filter(isEVMChain).find((chain) => chain.id === chainId) : undefined,\n          });\n        }\n\n        // Manage EIP-1193 event listeners\n        // https://eips.ethereum.org/EIPS/eip-1193#events\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged!.bind(this);\n          provider.on('accountsChanged', accountsChanged);\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this);\n          provider.on('chainChanged', chainChanged);\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this);\n          provider.on('disconnect', disconnect);\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId();\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error;\n            return { id: currentChainId };\n          });\n          currentChainId = chain?.id ?? currentChainId;\n        }\n\n        return { accounts, chainId: currentChainId };\n      } catch (err) {\n        const error = err as RpcError;\n        if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n        throw error;\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      // Manage EIP-1193 event listeners\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged);\n        chainChanged = undefined;\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect);\n        disconnect = undefined;\n      }\n\n      await provider.disconnect();\n    },\n    async getAccounts() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      const accounts = await provider.request({ method: 'eth_accounts' });\n      return accounts;\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      const hexChainId = await provider.request({ method: 'eth_chainId' });\n      return Number(hexChainId);\n    },\n    async getProvider() {\n      if (typeof window === 'undefined') return undefined;\n      const provider: Provider = window.particle?.ethereum;\n      return provider;\n    },\n    async isAuthorized() {\n      try {\n        const provider = await this.getProvider();\n        if (!provider) {\n          throw new ProviderNotFoundError();\n        }\n        if (provider.isSocialConnecting) {\n          const timeout = 3_0000; // social login timeout\n          await Promise.race([\n            ...(typeof window !== 'undefined'\n              ? [\n                  new Promise<boolean>((resolve) =>\n                    window.addEventListener('particle:socialConnectCompleted', () => resolve(true), { once: true })\n                  ),\n                ]\n              : []),\n            new Promise<boolean>((resolve) => setTimeout(() => resolve(true), timeout)),\n          ]);\n        }\n\n        const accounts = await this.getAccounts();\n        return !!accounts.length;\n      } catch {\n        return false;\n      }\n    },\n    /**\n     * particle does not support adding chains\n     */\n    async switchChain({ chainId }) {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      const chain = config.chains.filter(isEVMChain).find((x) => x.id === chainId);\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n\n      try {\n        await Promise.all([\n          provider\n            .request({\n              method: 'wallet_switchEthereumChain',\n              params: [{ chainId: numberToHex(chainId) }],\n            })\n            .then(async () => {\n              const currentChainId = await this.getChainId();\n              if (currentChainId === chainId) config.emitter.emit('change', { chainId });\n            }),\n          new Promise<void>((resolve) =>\n            config.emitter.once('change', ({ chainId: currentChainId }) => {\n              if (currentChainId === chainId) resolve();\n            })\n          ),\n        ]);\n\n        return chain;\n      } catch (err) {\n        const error = err as RpcError;\n        if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n        throw new SwitchChainError(error);\n      }\n    },\n    async onAccountsChanged(accounts) {\n      // Disconnect if there are no accounts\n      if (accounts.length === 0) this.onDisconnect();\n      // Regular change event\n      else\n        config.emitter.emit('change', {\n          accounts,\n        });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', { chainId });\n    },\n    async onDisconnect() {\n      const provider = await this.getProvider();\n\n      config.emitter.emit('disconnect');\n\n      // Manage EIP-1193 event listeners\n      if (provider) {\n        if (chainChanged) {\n          provider.removeListener('chainChanged', chainChanged);\n          chainChanged = undefined;\n        }\n        if (disconnect) {\n          provider.removeListener('disconnect', disconnect);\n          disconnect = undefined;\n        }\n      }\n    },\n    isInstalled() {\n      return true;\n    },\n  }));\n}\n", "import type {\n  ConnectParam,\n  ConnectWithEmailParam,\n  ConnectWithPhoneParam,\n  ConnectWithProvider,\n} from '@particle-network/auth-core';\nimport {\n  ChainNotConfiguredError,\n  ProviderNotFoundError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  createConnector,\n  isSolanaChain,\n  type Connector,\n  type RpcError,\n} from '@particle-network/connector-core';\nimport { type SolanaWallet } from './types';\n\ntype ConnectOptions = Omit<ConnectParam, 'chain'> & { chainId?: number; isReconnecting?: boolean };\n\nparticleSolana.type = 'particleAuth' as const;\nexport function particleSolana() {\n  type Provider = SolanaWallet | undefined;\n\n  type Properties = {\n    connect(options?: ConnectOptions): Promise<{\n      accounts: readonly string[];\n      chainId: number;\n    }>;\n  };\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined;\n  let chainChanged: Connector['onChainChanged'] | undefined;\n  let disconnect: Connector['onDisconnect'] | undefined;\n\n  return createConnector<Provider, Properties>((config) => ({\n    get icon() {\n      return 'https://static.particle.network/logo-small.png';\n    },\n    get id() {\n      return 'particleSolana';\n    },\n    get name() {\n      return 'Particle Auth';\n    },\n    type: particleSolana.type,\n    async connect(options: ConnectOptions) {\n      const { chainId, isReconnecting } = options;\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      if ((options as ConnectWithPhoneParam).phone && !(options as ConnectWithPhoneParam).code) {\n        throw new Error('Paramers error, need code.');\n      }\n\n      if ((options as ConnectWithEmailParam).email && !(options as ConnectWithEmailParam).code) {\n        throw new Error('Paramers error, need code.');\n      }\n\n      if ((options as ConnectWithProvider).provider && !(options as ConnectWithProvider).thirdpartyCode) {\n        throw new Error('Paramers error, need thirdpartyCode.');\n      }\n\n      let accounts: readonly string[] = [];\n      accounts = await this.getAccounts().catch(() => []);\n\n      try {\n        if (!isReconnecting) {\n          // \u5982\u679C\u5DF2\u7ECF\u767B\u5F55\u8FC7\uFF0C\u4E5F\u9700\u8981\u8C03\u7528\u8BE5\u65B9\u6CD5\n          // 1. \u5F53\u6CA1\u6709\u521B\u5EFA\u94B1\u5305\u65F6\u4F1A\u81EA\u52A8\u521B\u5EFA\n          // 2. \u5982\u679C\u5DF2\u7ECF\u767B\u5F55\u8FC7\u5207\u521B\u5EFA\u4E86\u94B1\u5305\uFF0C\u4F1A\u76F4\u63A5\u8FD4\u56DE\n          // 3. \u6CA1\u767B\u5F55\u8FC7\u4F1A\u8C03\u7528\u767B\u5F55\u65B9\u6CD5\n          await provider.connect({\n            ...options,\n            chain: chainId ? config.chains.filter(isSolanaChain).find((chain) => chain.id === chainId) : undefined,\n          });\n          accounts = [provider.selectedAddress!];\n        } else {\n          // \u91CD\u8FDE\u65F6\uFF0C\u5982\u679C\u94B1\u5305\u5DF2\u7ECF\u521B\u5EFA\u4E86\uFF0C\u9700\u8981\u8C03\u7528connect\u65B9\u6CD5\u521D\u59CB\u5316publicKey\n          if (accounts.length && !provider.isConnected) {\n            await provider.connect();\n          }\n        }\n\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged!.bind(this);\n          provider.on('accountsChanged', accountsChanged);\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this);\n          provider.on('chainChanged', chainChanged);\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this);\n          provider.on('disconnect', disconnect);\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId();\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error;\n            return { id: currentChainId };\n          });\n          currentChainId = chain?.id ?? currentChainId;\n        }\n\n        return { accounts, chainId: currentChainId };\n      } catch (err) {\n        const error = err as RpcError;\n        if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n        throw error;\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      // Manage EIP-1193 event listeners\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged);\n        chainChanged = undefined;\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect);\n        disconnect = undefined;\n      }\n\n      await provider.disconnect();\n    },\n    async getAccounts() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      if (provider.selectedAddress) {\n        return [provider.selectedAddress];\n      }\n      return [];\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      if (config.chains.find((chain) => chain.id === provider.chainId)) {\n        return provider.chainId;\n      }\n      const chainId = config.chains[0].id;\n      await this.switchChain!({ chainId });\n      return chainId;\n    },\n    async getProvider() {\n      if (typeof window === 'undefined') return undefined;\n      const provider: Provider = window.particle?.solana;\n      return provider;\n    },\n    async isAuthorized() {\n      try {\n        const provider = await this.getProvider();\n        if (!provider) {\n          throw new ProviderNotFoundError();\n        }\n        if (provider.isSocialConnecting) {\n          const timeout = 3_0000; // social login timeout\n          await Promise.race([\n            ...(typeof window !== 'undefined'\n              ? [\n                  new Promise<boolean>((resolve) =>\n                    window.addEventListener('particle:socialConnectCompleted', () => resolve(true), { once: true })\n                  ),\n                ]\n              : []),\n            new Promise<boolean>((resolve) => setTimeout(() => resolve(true), timeout)),\n          ]);\n        }\n\n        const accounts = await this.getAccounts();\n        return !!accounts.length;\n      } catch {\n        return false;\n      }\n    },\n    async switchChain({ chainId }) {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      const chain = config.chains.filter(isSolanaChain).find((x) => x.id === chainId);\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n\n      try {\n        await provider.switchChain(chainId);\n        return chain;\n      } catch (err) {\n        const error = err as RpcError;\n        if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n        throw new SwitchChainError(error);\n      }\n    },\n    async onAccountsChanged(accounts) {\n      // Disconnect if there are no accounts\n      if (accounts.length === 0) this.onDisconnect();\n      // Regular change event\n      else\n        config.emitter.emit('change', {\n          accounts,\n        });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', { chainId });\n    },\n    async onDisconnect() {\n      const provider = await this.getProvider();\n\n      config.emitter.emit('disconnect');\n\n      // Manage EIP-1193 event listeners\n      if (provider) {\n        if (chainChanged) {\n          provider.removeListener('chainChanged', chainChanged);\n          chainChanged = undefined;\n        }\n        if (disconnect) {\n          provider.removeListener('disconnect', disconnect);\n          disconnect = undefined;\n        }\n      }\n    },\n    isInstalled() {\n      return true;\n    },\n  }));\n}\n", "import { getCloudflareTurnstileResponse, getConnectCaptcha, getLatestAuthType } from '@particle-network/auth-core';\nimport type { EVMProvider, SolanaWallet } from '@particle-network/authkit';\n\nconst auth = {\n  getCloudflareTurnstileResponse,\n  getConnectCaptcha,\n  getLatestAuthType,\n};\n\ndeclare global {\n  interface Window {\n    particle?: {\n      ethereum?: EVMProvider;\n      solana?: SolanaWallet;\n    };\n  }\n}\n\nexport { auth, type EVMProvider, type SolanaWallet };\n", "export const version = '1.0.10';\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,IAAAA,oBAAyB;AACzB,qBAAqF;AACrF,IAAAC,yBAcO;AACP,qBAA4B;;;ACjB5B,kBAAwE;AAExE,IAAM,UAAU,oBAAI,IAA0B;AAEvC,SAAS,gBAAgB,OAA4B;AAC1D;AACE,UAAMC,UAAS,QAAQ,IAAI,MAAM,EAAE;AACnC,QAAIA;AAAQ,aAAOA;AAAA,EACrB;AAEA,QAAM,aAAS,gCAAmB;AAAA,IAChC;AAAA,IACA,eAAW,kBAAK;AAAA,EAClB,CAAC;AACD,UAAQ,IAAI,MAAM,IAAI,MAAM;AAE5B,SAAO;AACT;;;ACjBA,kBAAmE;AAGnE,IAAMC,WAAU,oBAAI,IAAwB;AAErC,SAAS,cAAc,OAAc,oBAAgE;AAC1G;AACE,UAAMC,UAASD,SAAQ,IAAI,MAAM,EAAE;AACnC,QAAIC;AAAQ,aAAOA;AAAA,EACrB;AAEA,QAAM,SAAS,IAAI,uBAAW,MAAM,QAAQ,QAAQ,KAAK,IAAK,kBAAkB;AAEhF,EAAAD,SAAQ,IAAI,MAAM,IAAI,MAAM;AAE5B,SAAO;AACT;;;ACVA,4BAUO;AAKP,YAAY,OAAO;AACZ,SAAS,cAAc;AAU5B,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,aAAO,uCAAsC,CAAC,YAAY;AAAA,IACxD,IAAI,OAAO;AACT,aAAO;AAAA,IACT;AAAA,IACA,IAAI,KAAK;AACP,aAAO;AAAA,IACT;AAAA,IACA,IAAI,OAAO;AACT,aAAO;AAAA,IACT;AAAA,IACA,MAAM,YAAY;AAAA,IAClB,MAAM,QAAQ,SAAyB;AA/C3C;AAgDM,YAAM,EAAE,SAAS,eAAe,IAAI;AACpC,YAAM,WAAW,MAAM,KAAK,YAAY;AACxC,UAAI,CAAC;AAAU,cAAM,IAAI,4CAAsB;AAE/C,UAAK,QAAkC,SAAS,CAAE,QAAkC,MAAM;AACxF,cAAM,IAAI,MAAM,4BAA4B;AAAA,MAC9C;AAEA,UAAK,QAAkC,SAAS,CAAE,QAAkC,MAAM;AACxF,cAAM,IAAI,MAAM,4BAA4B;AAAA,MAC9C;AAEA,UAAK,QAAgC,YAAY,CAAE,QAAgC,gBAAgB;AACjG,cAAM,IAAI,MAAM,sCAAsC;AAAA,MACxD;AAEA,UAAI,WAA8B,CAAC;AACnC,iBAAW,MAAM,KAAK,YAAY,EAAE,MAAM,MAAM,CAAC,CAAC;AAElD,UAAI;AACF,YAAI,EAAC,qCAAU,WAAU,CAAC,gBAAgB;AACxC,qBAAW,MAAM,SAAS,QAAQ;AAAA,YAChC,GAAG;AAAA,YACH,OAAO,UAAU,OAAO,OAAO,OAAO,gCAAU,EAAE,KAAK,CAAC,UAAU,MAAM,OAAO,OAAO,IAAI;AAAA,UAC5F,CAAC;AAAA,QACH;AAIA,YAAI,CAAC,iBAAiB;AACpB,4BAAkB,KAAK,kBAAmB,KAAK,IAAI;AACnD,mBAAS,GAAG,mBAAmB,eAAe;AAAA,QAChD;AACA,YAAI,CAAC,cAAc;AACjB,yBAAe,KAAK,eAAe,KAAK,IAAI;AAC5C,mBAAS,GAAG,gBAAgB,YAAY;AAAA,QAC1C;AACA,YAAI,CAAC,YAAY;AACf,uBAAa,KAAK,aAAa,KAAK,IAAI;AACxC,mBAAS,GAAG,cAAc,UAAU;AAAA,QACtC;AAGA,YAAI,iBAAiB,MAAM,KAAK,WAAW;AAC3C,YAAI,WAAW,mBAAmB,SAAS;AACzC,gBAAM,QAAQ,MAAM,KAAK,YAAa,EAAE,QAAQ,CAAC,EAAE,MAAM,CAAC,UAAU;AAClE,gBAAI,MAAM,SAAS,+CAAyB;AAAM,oBAAM;AACxD,mBAAO,EAAE,IAAI,eAAe;AAAA,UAC9B,CAAC;AACD,4BAAiB,oCAAO,OAAP,YAAa;AAAA,QAChC;AAEA,eAAO,EAAE,UAAU,SAAS,eAAe;AAAA,MAC7C,SAAS,KAAP;AACA,cAAM,QAAQ;AACd,YAAI,MAAM,SAAS,+CAAyB;AAAM,gBAAM,IAAI,+CAAyB,KAAK;AAC1F,cAAM;AAAA,MACR;AAAA,IACF;AAAA,IACA,MAAM,aAAa;AACjB,YAAM,WAAW,MAAM,KAAK,YAAY;AACxC,UAAI,CAAC;AAAU,cAAM,IAAI,4CAAsB;AAG/C,UAAI,cAAc;AAChB,iBAAS,eAAe,gBAAgB,YAAY;AACpD,uBAAe;AAAA,MACjB;AACA,UAAI,YAAY;AACd,iBAAS,eAAe,cAAc,UAAU;AAChD,qBAAa;AAAA,MACf;AAEA,YAAM,SAAS,WAAW;AAAA,IAC5B;AAAA,IACA,MAAM,cAAc;AAClB,YAAM,WAAW,MAAM,KAAK,YAAY;AACxC,UAAI,CAAC;AAAU,cAAM,IAAI,4CAAsB;AAC/C,YAAM,WAAW,MAAM,SAAS,QAAQ,EAAE,QAAQ,eAAe,CAAC;AAClE,aAAO;AAAA,IACT;AAAA,IACA,MAAM,aAAa;AACjB,YAAM,WAAW,MAAM,KAAK,YAAY;AACxC,UAAI,CAAC;AAAU,cAAM,IAAI,4CAAsB;AAC/C,YAAM,aAAa,MAAM,SAAS,QAAQ,EAAE,QAAQ,cAAc,CAAC;AACnE,aAAO,OAAO,UAAU;AAAA,IAC1B;AAAA,IACA,MAAM,cAAc;AAvIxB;AAwIM,UAAI,OAAO,WAAW;AAAa,eAAO;AAC1C,YAAM,YAAqB,YAAO,aAAP,mBAAiB;AAC5C,aAAO;AAAA,IACT;AAAA,IACA,MAAM,eAAe;AACnB,UAAI;AACF,cAAM,WAAW,MAAM,KAAK,YAAY;AACxC,YAAI,CAAC,UAAU;AACb,gBAAM,IAAI,4CAAsB;AAAA,QAClC;AACA,YAAI,SAAS,oBAAoB;AAC/B,gBAAM,UAAU;AAChB,gBAAM,QAAQ,KAAK;AAAA,YACjB,GAAI,OAAO,WAAW,cAClB;AAAA,cACE,IAAI;AAAA,gBAAiB,CAAC,YACpB,OAAO,iBAAiB,mCAAmC,MAAM,QAAQ,IAAI,GAAG,EAAE,MAAM,KAAK,CAAC;AAAA,cAChG;AAAA,YACF,IACA,CAAC;AAAA,YACL,IAAI,QAAiB,CAAC,YAAY,WAAW,MAAM,QAAQ,IAAI,GAAG,OAAO,CAAC;AAAA,UAC5E,CAAC;AAAA,QACH;AAEA,cAAM,WAAW,MAAM,KAAK,YAAY;AACxC,eAAO,CAAC,CAAC,SAAS;AAAA,MACpB,QAAE;AACA,eAAO;AAAA,MACT;AAAA,IACF;AAAA,IAIA,MAAM,YAAY,EAAE,QAAQ,GAAG;AAC7B,YAAM,WAAW,MAAM,KAAK,YAAY;AACxC,UAAI,CAAC;AAAU,cAAM,IAAI,4CAAsB;AAE/C,YAAM,QAAQ,OAAO,OAAO,OAAO,gCAAU,EAAE,KAAK,CAAC,MAAM,EAAE,OAAO,OAAO;AAC3E,UAAI,CAAC;AAAO,cAAM,IAAI,uCAAiB,IAAI,8CAAwB,CAAC;AAEpE,UAAI;AACF,cAAM,QAAQ,IAAI;AAAA,UAChB,SACG,QAAQ;AAAA,YACP,QAAQ;AAAA,YACR,QAAQ,CAAC,EAAE,aAAS,mCAAY,OAAO,EAAE,CAAC;AAAA,UAC5C,CAAC,EACA,KAAK,YAAY;AAChB,kBAAM,iBAAiB,MAAM,KAAK,WAAW;AAC7C,gBAAI,mBAAmB;AAAS,qBAAO,QAAQ,KAAK,UAAU,EAAE,QAAQ,CAAC;AAAA,UAC3E,CAAC;AAAA,UACH,IAAI;AAAA,YAAc,CAAC,YACjB,OAAO,QAAQ,KAAK,UAAU,CAAC,EAAE,SAAS,eAAe,MAAM;AAC7D,kBAAI,mBAAmB;AAAS,wBAAQ;AAAA,YAC1C,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AAED,eAAO;AAAA,MACT,SAAS,KAAP;AACA,cAAM,QAAQ;AACd,YAAI,MAAM,SAAS,+CAAyB;AAAM,gBAAM,IAAI,+CAAyB,KAAK;AAC1F,cAAM,IAAI,uCAAiB,KAAK;AAAA,MAClC;AAAA,IACF;AAAA,IACA,MAAM,kBAAkB,UAAU;AAEhC,UAAI,SAAS,WAAW;AAAG,aAAK,aAAa;AAAA;AAG3C,eAAO,QAAQ,KAAK,UAAU;AAAA,UAC5B;AAAA,QACF,CAAC;AAAA,IACL;AAAA,IACA,eAAe,OAAO;AACpB,YAAM,UAAU,OAAO,KAAK;AAC5B,aAAO,QAAQ,KAAK,UAAU,EAAE,QAAQ,CAAC;AAAA,IAC3C;AAAA,IACA,MAAM,eAAe;AACnB,YAAM,WAAW,MAAM,KAAK,YAAY;AAExC,aAAO,QAAQ,KAAK,YAAY;AAGhC,UAAI,UAAU;AACZ,YAAI,cAAc;AAChB,mBAAS,eAAe,gBAAgB,YAAY;AACpD,yBAAe;AAAA,QACjB;AACA,YAAI,YAAY;AACd,mBAAS,eAAe,cAAc,UAAU;AAChD,uBAAa;AAAA,QACf;AAAA,MACF;AAAA,IACF;AAAA,IACA,cAAc;AACZ,aAAO;AAAA,IACT;AAAA,EACF,EAAE;AACJ;;;ACrOA,IAAAE,yBASO;AAKP,eAAe,OAAO;AACf,SAAS,iBAAiB;AAU/B,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,aAAO,wCAAsC,CAAC,YAAY;AAAA,IACxD,IAAI,OAAO;AACT,aAAO;AAAA,IACT;AAAA,IACA,IAAI,KAAK;AACP,aAAO;AAAA,IACT;AAAA,IACA,IAAI,OAAO;AACT,aAAO;AAAA,IACT;AAAA,IACA,MAAM,eAAe;AAAA,IACrB,MAAM,QAAQ,SAAyB;AA9C3C;AA+CM,YAAM,EAAE,SAAS,eAAe,IAAI;AACpC,YAAM,WAAW,MAAM,KAAK,YAAY;AACxC,UAAI,CAAC;AAAU,cAAM,IAAI,6CAAsB;AAE/C,UAAK,QAAkC,SAAS,CAAE,QAAkC,MAAM;AACxF,cAAM,IAAI,MAAM,4BAA4B;AAAA,MAC9C;AAEA,UAAK,QAAkC,SAAS,CAAE,QAAkC,MAAM;AACxF,cAAM,IAAI,MAAM,4BAA4B;AAAA,MAC9C;AAEA,UAAK,QAAgC,YAAY,CAAE,QAAgC,gBAAgB;AACjG,cAAM,IAAI,MAAM,sCAAsC;AAAA,MACxD;AAEA,UAAI,WAA8B,CAAC;AACnC,iBAAW,MAAM,KAAK,YAAY,EAAE,MAAM,MAAM,CAAC,CAAC;AAElD,UAAI;AACF,YAAI,CAAC,gBAAgB;AAKnB,gBAAM,SAAS,QAAQ;AAAA,YACrB,GAAG;AAAA,YACH,OAAO,UAAU,OAAO,OAAO,OAAO,oCAAa,EAAE,KAAK,CAAC,UAAU,MAAM,OAAO,OAAO,IAAI;AAAA,UAC/F,CAAC;AACD,qBAAW,CAAC,SAAS,eAAgB;AAAA,QACvC,OAAO;AAEL,cAAI,SAAS,UAAU,CAAC,SAAS,aAAa;AAC5C,kBAAM,SAAS,QAAQ;AAAA,UACzB;AAAA,QACF;AAEA,YAAI,CAAC,iBAAiB;AACpB,4BAAkB,KAAK,kBAAmB,KAAK,IAAI;AACnD,mBAAS,GAAG,mBAAmB,eAAe;AAAA,QAChD;AACA,YAAI,CAAC,cAAc;AACjB,yBAAe,KAAK,eAAe,KAAK,IAAI;AAC5C,mBAAS,GAAG,gBAAgB,YAAY;AAAA,QAC1C;AACA,YAAI,CAAC,YAAY;AACf,uBAAa,KAAK,aAAa,KAAK,IAAI;AACxC,mBAAS,GAAG,cAAc,UAAU;AAAA,QACtC;AAGA,YAAI,iBAAiB,MAAM,KAAK,WAAW;AAC3C,YAAI,WAAW,mBAAmB,SAAS;AACzC,gBAAM,QAAQ,MAAM,KAAK,YAAa,EAAE,QAAQ,CAAC,EAAE,MAAM,CAAC,UAAU;AAClE,gBAAI,MAAM,SAAS,gDAAyB;AAAM,oBAAM;AACxD,mBAAO,EAAE,IAAI,eAAe;AAAA,UAC9B,CAAC;AACD,4BAAiB,oCAAO,OAAP,YAAa;AAAA,QAChC;AAEA,eAAO,EAAE,UAAU,SAAS,eAAe;AAAA,MAC7C,SAAS,KAAP;AACA,cAAM,QAAQ;AACd,YAAI,MAAM,SAAS,gDAAyB;AAAM,gBAAM,IAAI,gDAAyB,KAAK;AAC1F,cAAM;AAAA,MACR;AAAA,IACF;AAAA,IACA,MAAM,aAAa;AACjB,YAAM,WAAW,MAAM,KAAK,YAAY;AACxC,UAAI,CAAC;AAAU,cAAM,IAAI,6CAAsB;AAG/C,UAAI,cAAc;AAChB,iBAAS,eAAe,gBAAgB,YAAY;AACpD,uBAAe;AAAA,MACjB;AACA,UAAI,YAAY;AACd,iBAAS,eAAe,cAAc,UAAU;AAChD,qBAAa;AAAA,MACf;AAEA,YAAM,SAAS,WAAW;AAAA,IAC5B;AAAA,IACA,MAAM,cAAc;AAClB,YAAM,WAAW,MAAM,KAAK,YAAY;AACxC,UAAI,CAAC;AAAU,cAAM,IAAI,6CAAsB;AAC/C,UAAI,SAAS,iBAAiB;AAC5B,eAAO,CAAC,SAAS,eAAe;AAAA,MAClC;AACA,aAAO,CAAC;AAAA,IACV;AAAA,IACA,MAAM,aAAa;AACjB,YAAM,WAAW,MAAM,KAAK,YAAY;AACxC,UAAI,CAAC;AAAU,cAAM,IAAI,6CAAsB;AAC/C,UAAI,OAAO,OAAO,KAAK,CAAC,UAAU,MAAM,OAAO,SAAS,OAAO,GAAG;AAChE,eAAO,SAAS;AAAA,MAClB;AACA,YAAM,UAAU,OAAO,OAAO,GAAG;AACjC,YAAM,KAAK,YAAa,EAAE,QAAQ,CAAC;AACnC,aAAO;AAAA,IACT;AAAA,IACA,MAAM,cAAc;AApJxB;AAqJM,UAAI,OAAO,WAAW;AAAa,eAAO;AAC1C,YAAM,YAAqB,YAAO,aAAP,mBAAiB;AAC5C,aAAO;AAAA,IACT;AAAA,IACA,MAAM,eAAe;AACnB,UAAI;AACF,cAAM,WAAW,MAAM,KAAK,YAAY;AACxC,YAAI,CAAC,UAAU;AACb,gBAAM,IAAI,6CAAsB;AAAA,QAClC;AACA,YAAI,SAAS,oBAAoB;AAC/B,gBAAM,UAAU;AAChB,gBAAM,QAAQ,KAAK;AAAA,YACjB,GAAI,OAAO,WAAW,cAClB;AAAA,cACE,IAAI;AAAA,gBAAiB,CAAC,YACpB,OAAO,iBAAiB,mCAAmC,MAAM,QAAQ,IAAI,GAAG,EAAE,MAAM,KAAK,CAAC;AAAA,cAChG;AAAA,YACF,IACA,CAAC;AAAA,YACL,IAAI,QAAiB,CAAC,YAAY,WAAW,MAAM,QAAQ,IAAI,GAAG,OAAO,CAAC;AAAA,UAC5E,CAAC;AAAA,QACH;AAEA,cAAM,WAAW,MAAM,KAAK,YAAY;AACxC,eAAO,CAAC,CAAC,SAAS;AAAA,MACpB,QAAE;AACA,eAAO;AAAA,MACT;AAAA,IACF;AAAA,IACA,MAAM,YAAY,EAAE,QAAQ,GAAG;AAC7B,YAAM,WAAW,MAAM,KAAK,YAAY;AACxC,UAAI,CAAC;AAAU,cAAM,IAAI,6CAAsB;AAE/C,YAAM,QAAQ,OAAO,OAAO,OAAO,oCAAa,EAAE,KAAK,CAAC,MAAM,EAAE,OAAO,OAAO;AAC9E,UAAI,CAAC;AAAO,cAAM,IAAI,wCAAiB,IAAI,+CAAwB,CAAC;AAEpE,UAAI;AACF,cAAM,SAAS,YAAY,OAAO;AAClC,eAAO;AAAA,MACT,SAAS,KAAP;AACA,cAAM,QAAQ;AACd,YAAI,MAAM,SAAS,gDAAyB;AAAM,gBAAM,IAAI,gDAAyB,KAAK;AAC1F,cAAM,IAAI,wCAAiB,KAAK;AAAA,MAClC;AAAA,IACF;AAAA,IACA,MAAM,kBAAkB,UAAU;AAEhC,UAAI,SAAS,WAAW;AAAG,aAAK,aAAa;AAAA;AAG3C,eAAO,QAAQ,KAAK,UAAU;AAAA,UAC5B;AAAA,QACF,CAAC;AAAA,IACL;AAAA,IACA,eAAe,OAAO;AACpB,YAAM,UAAU,OAAO,KAAK;AAC5B,aAAO,QAAQ,KAAK,UAAU,EAAE,QAAQ,CAAC;AAAA,IAC3C;AAAA,IACA,MAAM,eAAe;AACnB,YAAM,WAAW,MAAM,KAAK,YAAY;AAExC,aAAO,QAAQ,KAAK,YAAY;AAGhC,UAAI,UAAU;AACZ,YAAI,cAAc;AAChB,mBAAS,eAAe,gBAAgB,YAAY;AACpD,yBAAe;AAAA,QACjB;AACA,YAAI,YAAY;AACd,mBAAS,eAAe,cAAc,UAAU;AAChD,uBAAa;AAAA,QACf;AAAA,MACF;AAAA,IACF;AAAA,IACA,cAAc;AACZ,aAAO;AAAA,IACT;AAAA,EACF,EAAE;AACJ;;;ACrOA,uBAAqF;AAGrF,IAAM,OAAO;AAAA,EACX;AAAA,EACA;AAAA,EACA;AACF;;;ALkCA,qBAAqB,OAAO;AACrB,SAAS,qBAAqB,aAAmC,CAAC,GAAG;AAC1E,QAAM,EAAE,WAAW,UAAU,qBAAqB,WAAW,SAAS,IAAI;AAC1E,MAAI,aAAa,UAAU,WAAW,GAAG;AACvC,UAAM,IAAI,MAAM,4BAA4B;AAAA,EAC9C;AAOA,QAAM,mBAAoB,aAA4B,OAAO,OAAO,0BAAQ;AAE5E,aAAO,8CAAwD,CAAC,YAAY;AAC1E,UAAM,EAAE,QAAQ,SAAS,SAAS,WAAW,WAAW,MAAM,IAAI;AAClE,UAAM,aAAS,4BAAY,MAAM,OAAO;AAExC,aAAS,MAAM,aAA2C;AA3D9D;AA6DM,YAAM,cAAU,sCAAiC;AACjD,YAAM,SAAS,YAAY,EAAE,SAAS,QAAQ,SAAS,QAAQ,CAAC;AAChE,YAAM,YAAY;AAAA,QAChB,GAAG;AAAA,QACH;AAAA,QACA,KAAK,QAAQ;AAAA,QACb,WAAW,OAAO,GAAG,YAAY,EAAE,SAAS,KAAK,IAAK,QAAmB;AAAA,QACzE,qBAAqB,qBAAqB;AAAA,MAC5C;AACA,sBAAU,UAAV;AACA,aAAO;AAAA,IACT;AAEA,UAAM,YAAiC,CAAC;AACxC,QAAI,QAAQ,KAAK,iCAAU,GAAG;AAC5B,gBAAU,KAAK,YAAY,CAAC;AAAA,IAC9B;AACA,QAAI,QAAQ,KAAK,oCAAa,GAAG;AAC/B,gBAAU,KAAK,eAAe,CAAC;AAAA,IACjC;AAEA,UAAM,iBAAa,4BAAY,MAAM,UAAU,IAAI,KAAK,CAAC;AAEzD,aAAS,UAAkD,SAAwC;AACjG,YAAM,QAAQ,OAAO,SAAS,EAAE,KAAK,CAACC,WAAUA,OAAM,OAAO,OAAO;AACpE,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,+CAAwB;AAAA,MACpC;AACA,cAAI,mCAAW,KAAK,GAAG;AACrB,eAAO,gBAAgB,KAAK;AAAA,MAC9B;AAEA,aAAO,cAAc,KAAK;AAAA,IAC5B;AAEA,WAAO;AAAA,MACL,IAAI,OAAO;AACT,eAAO,qBAAqB;AAAA,MAC9B;AAAA,MACA,IAAI,SAAS;AACX,eAAO,OAAO,SAAS;AAAA,MACzB;AAAA,MACA,IAAI,aAAa;AACf,eAAO,WAAW,SAAS;AAAA,MAC7B;AAAA,MACA,OAAO;AAAA,MACP;AAAA,MACA;AAAA,MACA,aAAa;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA,QACA,WAAW;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA,QACA,gBAAgB;AAAA,QAChB,aAAa;AAAA,UACX,QAAQ;AAAA,UACR,GAAG,uCAAW;AAAA,QAChB;AAAA,QACA,QAAQ;AAAA,QACR,QAAQ;AAAA,MACV;AAAA,MACA;AAAA,MACA,WAAW;AAAA,QACT,YAAY;AAAA,UACV;AAAA,QACF;AAAA,MACF;AAAA,MACA;AAAA,IACF;AAAA,EACF,CAAC;AACH;;;AMtIO,IAAM,UAAU;",
  "names": ["import_auth_core", "import_connector_core", "client", "clients", "client", "import_connector_core", "chain"]
}
