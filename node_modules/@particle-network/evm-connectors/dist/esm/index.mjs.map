{
  "version": 3,
  "sources": ["../../src/coinbaseWallet.ts", "../../src/injected.ts", "../../src/passkeySmartWallet.ts", "../../src/provider/passkeyProvider.ts", "../../src/utils/passkeys.ts", "../../src/utils/index.ts", "../../src/walletConnect.ts", "../../src/defaultConnectorFns.ts", "../../src/store.ts", "../../src/getPublicClient.ts", "../../src/version.ts"],
  "sourcesContent": ["import type { CoinbaseWalletSDK, Preference, ProviderInterface } from '@coinbase/wallet-sdk';\nimport {\n  ChainNotConfiguredError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  createConnector,\n  numberToHex,\n  type AddEthereumChainParameter,\n  type Connector,\n  type Evaluate,\n  type Mutable,\n  type ProviderRpcError,\n} from '@particle-network/connector-core';\n\ntype VersionParameters = Mutable<\n  Omit<ConstructorParameters<typeof CoinbaseWalletSDK>[0], 'appChainIds'> & {\n    /**\n     * Preference for the type of wallet to display.\n     * @default 'all'\n     */\n    preference?: Preference['options'] | undefined;\n  }\n>;\n\nexport type CoinbaseWalletParameters = Evaluate<VersionParameters>;\n\ncoinbaseWallet.type = 'coinbaseWallet' as const;\nexport function coinbaseWallet(parameters: CoinbaseWalletParameters = {}) {\n  type Provider = ProviderInterface & {\n    // for backwards compatibility\n    close?(): void;\n  };\n\n  let sdk: CoinbaseWalletSDK | undefined;\n  let walletProvider: Provider | undefined;\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined;\n  let chainChanged: Connector['onChainChanged'] | undefined;\n  let disconnect: Connector['onDisconnect'] | undefined;\n\n  return createConnector<Provider>((config) => ({\n    id: 'coinbaseWalletSDK',\n    name: 'Coinbase Wallet',\n    type: coinbaseWallet.type,\n    async connect({ chainId } = {}) {\n      try {\n        const provider = await this.getProvider();\n        const accounts = (await provider.request({\n          method: 'eth_requestAccounts',\n        })) as string[];\n\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged!.bind(this);\n          provider.on('accountsChanged', accountsChanged);\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this);\n          provider.on('chainChanged', chainChanged);\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this);\n          provider.on('disconnect', disconnect);\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId();\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error;\n            return { id: currentChainId };\n          });\n          currentChainId = chain?.id ?? currentChainId;\n        }\n\n        return { accounts, chainId: currentChainId };\n      } catch (error) {\n        if (/(user closed modal|accounts received is empty|user denied account)/i.test((error as Error).message))\n          throw new UserRejectedRequestError(error as Error);\n        throw error;\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider();\n\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged);\n        accountsChanged = undefined;\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged);\n        chainChanged = undefined;\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect);\n        disconnect = undefined;\n      }\n\n      provider.disconnect();\n      provider.close?.();\n    },\n    async getAccounts() {\n      const provider = await this.getProvider();\n      return await provider.request<string[]>({\n        method: 'eth_accounts',\n      });\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      const chainId = await provider.request<string>({\n        method: 'eth_chainId',\n      });\n      return Number(chainId);\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        // Unwrapping import for Vite compatibility.\n        // See: https://github.com/vitejs/vite/issues/9703\n        const { default: CoinbaseSDK_ } = await import('@coinbase/wallet-sdk');\n        const CoinbaseSDK = (() => {\n          if (typeof CoinbaseSDK_ !== 'function' && typeof (CoinbaseSDK_ as any).default === 'function')\n            return (CoinbaseSDK_ as any).default;\n          return CoinbaseSDK_;\n        })();\n\n        sdk = new CoinbaseSDK({\n          ...parameters,\n          appChainIds: config.chains.map((x) => x.id),\n        }) as CoinbaseWalletSDK;\n\n        walletProvider = sdk.makeWeb3Provider({\n          ...parameters,\n          options: parameters.preference ?? 'all',\n        });\n      }\n\n      return walletProvider;\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts();\n        return !!accounts.length;\n      } catch {\n        return false;\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId);\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n\n      const provider = await this.getProvider();\n\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chain.id) }],\n        });\n\n        return chain;\n      } catch (error) {\n        // Indicates chain is not added to provider\n        if ((error as ProviderRpcError).code === 4902) {\n          try {\n            let blockExplorerUrls: string[] | undefined;\n            if (addEthereumChainParameter?.blockExplorerUrls)\n              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;\n            else blockExplorerUrls = chain.blockExplorers?.default.url ? [chain.blockExplorers?.default.url] : [];\n\n            let rpcUrls: readonly string[];\n            if (addEthereumChainParameter?.rpcUrls?.length) rpcUrls = addEthereumChainParameter.rpcUrls;\n            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? ''];\n\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,\n              rpcUrls,\n            } satisfies AddEthereumChainParameter;\n\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [addEthereumChain],\n            });\n\n            return chain;\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error);\n          }\n        }\n\n        throw new SwitchChainError(error as Error);\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect();\n      else\n        config.emitter.emit('change', {\n          accounts,\n        });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', { chainId });\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect');\n\n      const provider = await this.getProvider();\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged);\n        accountsChanged = undefined;\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged);\n        chainChanged = undefined;\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect);\n        disconnect = undefined;\n      }\n    },\n    isInstalled(): boolean {\n      return true;\n    },\n  }));\n}\n", "import {\n  ChainNotConfiguredError,\n  ProviderNotFoundError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  createConnector,\n  numberToHex,\n  type AddEthereumChainParameter,\n  type Connector,\n  type Evaluate,\n  type ProviderConnectInfo,\n  type ProviderRpcError,\n  type RpcError,\n} from '@particle-network/connector-core';\nimport { ResourceUnavailableRpcError, withRetry, withTimeout, type EIP1193Provider } from 'viem';\n\nexport type InjectedParameters = {\n  /**\n   * MetaMask and other injected providers do not support programmatic disconnect.\n   * This flag simulates the disconnect behavior by keeping track of connection status in storage. See [GitHub issue](https://github.com/MetaMask/metamask-extension/issues/10353) for more info.\n   * @default true\n   */\n  shimDisconnect?: boolean | undefined;\n  unstableShimAsyncInject?: boolean | number | undefined;\n  /**\n   * [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Provider to target\n   */\n  target?: TargetId | Target | (() => Target | undefined) | undefined;\n};\n\nconst targetMap = {\n  coinbaseWallet: {\n    id: 'coinbaseWallet',\n    name: 'Coinbase Wallet',\n    provider(window) {\n      if (window?.coinbaseWalletExtension) return window.coinbaseWalletExtension;\n      return findProvider(window, 'isCoinbaseWallet');\n    },\n  },\n  metaMask: {\n    id: 'metaMask',\n    name: 'MetaMask',\n    provider(window) {\n      return findProvider(window, (provider) => {\n        if (!provider.isMetaMask) return false;\n        // Brave tries to make itself look like MetaMask\n        // Could also try RPC `web3_clientVersion` if following is unreliable\n        if (provider.isBraveWallet && !provider._events && !provider._state) return false;\n        // Other wallets that try to look like MetaMask\n        const flags: WalletProviderFlags[] = [\n          'isApexWallet',\n          'isAvalanche',\n          'isBitKeep',\n          'isBlockWallet',\n          'isKuCoinWallet',\n          'isMathWallet',\n          'isOkxWallet',\n          'isOKExWallet',\n          'isOneInchIOSWallet',\n          'isOneInchAndroidWallet',\n          'isOpera',\n          'isPortal',\n          'isRabby',\n          'isTokenPocket',\n          'isTokenary',\n          'isZerion',\n        ];\n        for (const flag of flags) if (provider[flag]) return false;\n        return true;\n      });\n    },\n  },\n  phantom: {\n    id: 'phantom',\n    name: 'Phantom',\n    provider(window) {\n      if (window?.phantom?.ethereum) return window.phantom?.ethereum;\n      return findProvider(window, 'isPhantom');\n    },\n  },\n  safePal: {\n    id: 'safePal',\n    name: 'SafePal',\n    provider(window) {\n      return window?.safepalProvider;\n    },\n  },\n  coin98: {\n    id: 'coin98',\n    name: 'Coin98 Wallet',\n    provider(window) {\n      if (window?.coin98?.provider) return window.coin98?.provider;\n      return findProvider(window, 'isCoin98');\n    },\n  },\n  onekey: {\n    id: 'onekey',\n    name: 'OneKey',\n    provider(window) {\n      return window?.$onekey?.ethereum;\n    },\n  },\n  bybitWallet: {\n    id: 'bybitWallet',\n    name: 'Bybit Wallet',\n    provider(window) {\n      return window?.bybitWallet;\n    },\n  },\n  braveWallet: {\n    id: 'braveWallet',\n    name: 'Brave Wallet',\n    provider(window) {\n      return window?.braveEthereum;\n    },\n  },\n} as const satisfies TargetMap;\n\ninjected.type = 'injected' as const;\nexport function injected(parameters: InjectedParameters = {}) {\n  const { shimDisconnect = true, unstableShimAsyncInject } = parameters;\n\n  function getTarget(): Evaluate<Target & { id: string }> {\n    const target = parameters.target;\n    if (typeof target === 'function') {\n      const result = target();\n      if (result) return result;\n    }\n\n    if (typeof target === 'object') return target;\n\n    if (typeof target === 'string')\n      return {\n        ...(targetMap[target as keyof typeof targetMap] ?? {\n          id: target,\n          name: `${target[0]!.toUpperCase()}${target.slice(1)}`,\n          provider: `is${target[0]!.toUpperCase()}${target.slice(1)}`,\n        }),\n      };\n\n    return {\n      id: 'injected',\n      name: 'Injected',\n      provider(window) {\n        return window?.ethereum;\n      },\n    };\n  }\n\n  type Provider = WalletProvider | undefined;\n  type Properties = {\n    onConnect(connectInfo: ProviderConnectInfo): void;\n  };\n  type StorageItem = {\n    [_ in 'injected.connected' | `${string}.disconnected`]: true;\n  };\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined;\n  let chainChanged: Connector['onChainChanged'] | undefined;\n  let connect: Connector['onConnect'] | undefined;\n  let disconnect: Connector['onDisconnect'] | undefined;\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    get icon() {\n      return getTarget().icon;\n    },\n    get id() {\n      return getTarget().id;\n    },\n    get name() {\n      return getTarget().name;\n    },\n    type: injected.type,\n    async setup() {\n      const provider = await this.getProvider();\n      // Only start listening for events if `target` is set, otherwise `injected()` will also receive events\n      if (provider && parameters.target) {\n        if (!connect) {\n          connect = this.onConnect.bind(this);\n          // provider.on('connect', connect);\n        }\n\n        // We shouldn't need to listen for `'accountsChanged'` here since the `'connect'` event should suffice (and wallet shouldn't be connected yet).\n        // Some wallets, like MetaMask, do not implement the `'connect'` event and overload `'accountsChanged'` instead.\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged!.bind(this);\n          provider.on('accountsChanged', accountsChanged);\n        }\n      }\n    },\n    async connect({ chainId, isReconnecting } = {}) {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      let accounts: readonly string[] = [];\n      if (isReconnecting) {\n        accounts = await this.getAccounts().catch(() => []);\n      } else if (shimDisconnect) {\n        // Attempt to show another prompt for selecting account if `shimDisconnect` flag is enabled\n        try {\n          const permissions = await provider.request({\n            method: 'wallet_requestPermissions',\n            // eslint-disable-next-line camelcase\n            params: [{ eth_accounts: {} }],\n          });\n          console.log('inject provider connect, permissions:', permissions);\n          accounts = permissions[0]?.caveats?.[0]?.value as string[];\n          if (accounts?.length) {\n            const sortedAccounts = await this.getAccounts();\n            accounts = sortedAccounts;\n          }\n        } catch (err) {\n          const error = err as RpcError;\n          // Not all injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n          // Only bubble up error if user rejects request\n          if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n          // Or prompt is already open\n          if (error.code === ResourceUnavailableRpcError.code) throw error;\n        }\n      }\n\n      try {\n        if (!accounts?.length && !isReconnecting) {\n          const requestedAccounts = await provider.request({\n            method: 'eth_requestAccounts',\n          });\n          accounts = requestedAccounts;\n        }\n\n        // Manage EIP-1193 event listeners\n        // https://eips.ethereum.org/EIPS/eip-1193#events\n        if (connect) {\n          provider.removeListener('connect', connect);\n          connect = undefined;\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged!.bind(this);\n          provider.on('accountsChanged', accountsChanged);\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this);\n          provider.on('chainChanged', chainChanged);\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this);\n          provider.on('disconnect', disconnect);\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId();\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error;\n            return { id: currentChainId };\n          });\n          currentChainId = chain?.id ?? currentChainId;\n        }\n\n        // Remove disconnected shim if it exists\n        if (shimDisconnect) await config.storage?.removeItem(`${this.id}.disconnected`);\n\n        // Add connected shim if no target exists\n        if (!parameters.target) await config.storage?.setItem('injected.connected', true);\n\n        return { accounts, chainId: currentChainId };\n      } catch (err) {\n        const error = err as RpcError;\n        if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n        if (error.code === ResourceUnavailableRpcError.code) throw new ResourceUnavailableRpcError(error);\n        throw error;\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      // Manage EIP-1193 event listeners\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged);\n        chainChanged = undefined;\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect);\n        disconnect = undefined;\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this);\n        // provider.on('connect', connect);\n      }\n\n      // Experimental support for MetaMask disconnect\n      // https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-2.md\n      try {\n        await provider.request({\n          method: 'wallet_revokePermissions',\n          // eslint-disable-next-line camelcase\n          params: [{ eth_accounts: {} }],\n        });\n      } catch (e) {\n        // ignore\n      }\n\n      // Add shim signalling connector is disconnected\n      if (shimDisconnect) {\n        await config.storage?.setItem(`${this.id}.disconnected`, true);\n      }\n\n      if (!parameters.target) await config.storage?.removeItem('injected.connected');\n    },\n    async getAccounts() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      const accounts = await provider.request({ method: 'eth_accounts' });\n      return accounts;\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      const hexChainId = await provider.request({ method: 'eth_chainId' });\n      return Number(hexChainId);\n    },\n    async getProvider() {\n      if (typeof window === 'undefined') return undefined;\n\n      let provider: Provider;\n      const target = getTarget();\n      if (typeof target.provider === 'function') provider = target.provider(window as Window | undefined);\n      else if (typeof target.provider === 'string') provider = findProvider(window, target.provider);\n      else provider = target.provider;\n\n      // Some wallets do not conform to EIP-1193 (e.g. Trust Wallet)\n      // https://github.com/wevm/wagmi/issues/3526#issuecomment-1912683002\n      if (provider && !provider.removeListener) {\n        // Try using `off` handler if it exists, otherwise noop\n        if ('off' in provider && typeof provider.off === 'function')\n          provider.removeListener = provider.off as typeof provider.removeListener;\n        else provider.removeListener = () => {};\n      }\n\n      return provider;\n    },\n    async isAuthorized() {\n      try {\n        const isDisconnected =\n          shimDisconnect &&\n          // If shim exists in storage, connector is disconnected\n          (await config.storage?.getItem(`${this.id}.disconnected`));\n        if (isDisconnected) return false;\n\n        // Don't allow injected connector to connect if no target is set and it hasn't already connected\n        // (e.g. flag in storage is not set). This prevents a targetless injected connector from connecting\n        // automatically whenever there is a targeted connector configured.\n        if (!parameters.target) {\n          const connected = await config.storage?.getItem('injected.connected');\n          if (!connected) return false;\n        }\n\n        const provider = await this.getProvider();\n        if (!provider) {\n          if (unstableShimAsyncInject !== undefined && unstableShimAsyncInject !== false) {\n            // If no provider is found, check for async injection\n            // https://github.com/wevm/references/issues/167\n            // https://github.com/MetaMask/detect-provider\n            const handleEthereum = async () => {\n              if (typeof window !== 'undefined') window.removeEventListener('ethereum#initialized', handleEthereum);\n              const provider = await this.getProvider();\n              return !!provider;\n            };\n            const timeout = typeof unstableShimAsyncInject === 'number' ? unstableShimAsyncInject : 1_000;\n            const res = await Promise.race([\n              ...(typeof window !== 'undefined'\n                ? [\n                    new Promise<boolean>((resolve) =>\n                      window.addEventListener('ethereum#initialized', () => resolve(handleEthereum()), { once: true })\n                    ),\n                  ]\n                : []),\n              new Promise<boolean>((resolve) => setTimeout(() => resolve(handleEthereum()), timeout)),\n            ]);\n            if (res) return true;\n          }\n\n          throw new ProviderNotFoundError();\n        }\n\n        // We are applying a retry & timeout strategy here as some injected wallets (e.g. MetaMask) fail to\n        // immediately resolve a JSON-RPC request on page load.\n        const accounts = await withRetry(() =>\n          withTimeout(() => this.getAccounts(), {\n            timeout: 100,\n          })\n        );\n        return !!accounts.length;\n      } catch {\n        return false;\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      const chain = config.chains.find((x) => x.id === chainId);\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n\n      try {\n        await Promise.all([\n          provider\n            .request({\n              method: 'wallet_switchEthereumChain',\n              params: [{ chainId: numberToHex(chainId) }],\n            })\n            // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.\n            // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.\n            // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via\n            // this callback or an externally emitted `'chainChanged'` event.\n            // https://github.com/MetaMask/metamask-extension/issues/24247\n            .then(async () => {\n              const currentChainId = await this.getChainId();\n              if (currentChainId === chainId) config.emitter.emit('change', { chainId });\n            }),\n          new Promise<void>((resolve) =>\n            config.emitter.once('change', ({ chainId: currentChainId }) => {\n              if (currentChainId === chainId) resolve();\n            })\n          ),\n        ]);\n        return chain;\n      } catch (err) {\n        const error = err as RpcError;\n\n        // Indicates chain is not added to provider\n        if (\n          error.code === 4902 ||\n          // Unwrapping for MetaMask Mobile\n          // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n          (error as ProviderRpcError<{ originalError?: { code: number } }>)?.data?.originalError?.code === 4902\n        ) {\n          try {\n            let blockExplorerUrls: string[];\n            if (addEthereumChainParameter?.blockExplorerUrls)\n              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;\n            else blockExplorerUrls = chain.blockExplorers?.default.url ? [chain.blockExplorers?.default.url] : [];\n\n            let rpcUrls: readonly string[];\n            if (addEthereumChainParameter?.rpcUrls?.length) rpcUrls = addEthereumChainParameter.rpcUrls;\n            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? ''];\n\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,\n              rpcUrls,\n            } satisfies AddEthereumChainParameter;\n\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [addEthereumChain],\n            });\n\n            const currentChainId = await this.getChainId();\n            if (currentChainId !== chainId)\n              throw new UserRejectedRequestError(new Error('User rejected switch after adding network.'));\n            return chain;\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error);\n          }\n        }\n\n        if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n        throw new SwitchChainError(error);\n      }\n    },\n    async onAccountsChanged(accounts) {\n      // Disconnect if there are no accounts\n      if (accounts.length === 0) this.onDisconnect();\n      // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)\n      else if (config.emitter.listenerCount('connect')) {\n        const chainId = (await this.getChainId()).toString();\n        this.onConnect({ chainId });\n        // Remove disconnected shim if it exists\n        if (shimDisconnect) await config.storage?.removeItem(`${this.id}.disconnected`);\n      }\n      // Regular change event\n      else\n        config.emitter.emit('change', {\n          accounts,\n        });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', { chainId });\n    },\n    async onConnect(connectInfo) {\n      const accounts = await this.getAccounts();\n      if (accounts.length === 0) return;\n\n      const chainId = Number(connectInfo.chainId);\n      config.emitter.emit('connect', { accounts, chainId });\n\n      // Manage EIP-1193 event listeners\n      const provider = await this.getProvider();\n      if (provider) {\n        if (connect) {\n          provider.removeListener('connect', connect);\n          connect = undefined;\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged!.bind(this);\n          provider.on('accountsChanged', accountsChanged);\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this);\n          provider.on('chainChanged', chainChanged);\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this);\n          provider.on('disconnect', disconnect);\n        }\n      }\n    },\n    async onDisconnect(error) {\n      const provider = await this.getProvider();\n\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error && (error as RpcError<1013>).code === 1013) {\n        if (provider && !!(await this.getAccounts()).length) return;\n      }\n\n      // No need to remove `${this.id}.disconnected` from storage because `onDisconnect` is typically\n      // only called when the wallet is disconnected through the wallet's interface, meaning the wallet\n      // actually disconnected and we don't need to simulate it.\n      config.emitter.emit('disconnect');\n\n      // Manage EIP-1193 event listeners\n      if (provider) {\n        if (chainChanged) {\n          provider.removeListener('chainChanged', chainChanged);\n          chainChanged = undefined;\n        }\n        if (disconnect) {\n          provider.removeListener('disconnect', disconnect);\n          disconnect = undefined;\n        }\n        if (!connect) {\n          connect = this.onConnect.bind(this);\n          // provider.on('connect', connect);\n        }\n      }\n    },\n    isInstalled(): boolean {\n      if (typeof window === 'undefined') return false;\n\n      let provider: Provider;\n      const target = getTarget();\n      if (typeof target.provider === 'function') provider = target.provider(window as Window | undefined);\n      else if (typeof target.provider === 'string') provider = findProvider(window, target.provider);\n      else provider = target.provider;\n\n      return Boolean(provider);\n    },\n  }));\n}\n\ntype Target = {\n  icon?: string | undefined;\n  id: string;\n  name: string;\n  provider: WalletProviderFlags | WalletProvider | ((window?: Window | undefined) => WalletProvider | undefined);\n};\n\n/** @deprecated */\ntype TargetId =\n  Evaluate<WalletProviderFlags> extends `is${infer name}`\n    ? name extends `${infer char}${infer rest}`\n      ? `${Lowercase<char>}${rest}`\n      : never\n    : never;\n\ntype TargetMap = { [_ in TargetId]?: Target | undefined };\n\n/** @deprecated */\nexport type WalletProviderFlags =\n  | 'isApexWallet'\n  | 'isAvalanche'\n  | 'isBackpack'\n  | 'isBifrost'\n  | 'isBitKeep'\n  | 'isBitski'\n  | 'isBlockWallet'\n  | 'isBraveWallet'\n  | 'isCoinbaseWallet'\n  | 'isDawn'\n  | 'isEnkrypt'\n  | 'isExodus'\n  | 'isFrame'\n  | 'isFrontier'\n  | 'isGamestop'\n  | 'isHyperPay'\n  | 'isImToken'\n  | 'isKuCoinWallet'\n  | 'isMathWallet'\n  | 'isMetaMask'\n  | 'isOkxWallet'\n  | 'isOKExWallet'\n  | 'isOneInchAndroidWallet'\n  | 'isOneInchIOSWallet'\n  | 'isOpera'\n  | 'isPhantom'\n  | 'isPortal'\n  | 'isRabby'\n  | 'isRainbow'\n  | 'isStatus'\n  | 'isTally'\n  | 'isTokenPocket'\n  | 'isTokenary'\n  | 'isTrust'\n  | 'isTrustWallet'\n  | 'isXDEFI'\n  | 'isSafePal'\n  | 'isCoin98'\n  | 'isOnekey'\n  | 'isBybitWallet'\n  | 'isZerion';\n\n// type EIP1193Provider = {\n//   on: (event: string, listener: EIP1193EventMap[TEvent]) => void;\n//   removeListener: (event: string, listener: EIP1193EventMap[TEvent]) => void;\n//   request: EIP1193RequestFn<EIP1474Methods>;\n// };\n\ntype WalletProvider = Evaluate<\n  EIP1193Provider & {\n    [key in WalletProviderFlags]?: true | undefined;\n  } & {\n    providers?: WalletProvider[] | undefined;\n    /** Only exists in MetaMask as of 2022/04/03 */\n    _events?: { connect?: (() => void) | undefined } | undefined;\n    /** Only exists in MetaMask as of 2022/04/03 */\n    _state?:\n      | {\n          accounts?: string[];\n          initialized?: boolean;\n          isConnected?: boolean;\n          isPermanentlyDisconnected?: boolean;\n          isUnlocked?: boolean;\n        }\n      | undefined;\n  }\n>;\n\ntype Window = {\n  coinbaseWalletExtension?: WalletProvider | undefined;\n  ethereum?: WalletProvider | undefined;\n  phantom?: { ethereum: WalletProvider } | undefined;\n  coin98?: { provider: WalletProvider } | undefined;\n  $onekey?: { ethereum: WalletProvider } | undefined;\n  safepalProvider?: WalletProvider | undefined;\n  bybitWallet?: WalletProvider | undefined;\n  braveEthereum?: WalletProvider | undefined;\n};\n\nfunction findProvider(\n  window: globalThis.Window | Window | undefined,\n  select?: WalletProviderFlags | ((provider: WalletProvider) => boolean)\n) {\n  function isProvider(provider: WalletProvider) {\n    if (typeof select === 'function') return select(provider);\n    if (typeof select === 'string') return provider[select];\n    return true;\n  }\n\n  const ethereum = (window as Window).ethereum;\n  if (ethereum?.providers) return ethereum.providers.find((provider) => isProvider(provider));\n  if (ethereum && isProvider(ethereum)) return ethereum;\n  return undefined;\n}\n", "import type { PasskeyOption } from '@particle-network/aa';\nimport {\n  ChainNotConfiguredError,\n  ProviderNotFoundError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  createConnector,\n  numberToHex,\n  type Connector,\n} from '@particle-network/connector-core';\nimport { PasskeyProvider, type PasskeyStorageItem } from './provider/passkeyProvider';\nimport { isPasskeySupported } from './utils/passkeys';\n\ntype PasskeySmartWalletParamers = {\n  registrationName?: () => string;\n};\n\npasskeySmartWallet.type = 'passkeySmartWallet' as const;\nexport function passkeySmartWallet(parameters: PasskeySmartWalletParamers = {}) {\n  type Provider = PasskeyProvider;\n\n  type Properties = {\n    getPasskeyOption: () => Promise<PasskeyOption | null>;\n    connect(\n      parameters?:\n        | {\n            chainId?: number | undefined;\n            isReconnecting?: boolean | undefined;\n            isRegistering?: boolean | undefined;\n          }\n        | undefined\n    ): Promise<{\n      accounts: readonly string[];\n      chainId: number;\n    }>;\n  };\n\n  let walletProvider: Provider | undefined;\n\n  let chainChanged: Connector['onChainChanged'] | undefined;\n\n  const { registrationName } = parameters;\n\n  let isUserVerifyingPlatformAuthenticatorAvailable: boolean | undefined;\n\n  if (isPasskeySupported()) {\n    window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()\n      .then((v) => {\n        isUserVerifyingPlatformAuthenticatorAvailable = v;\n      })\n      .catch(() => {\n        isUserVerifyingPlatformAuthenticatorAvailable = false;\n      });\n  }\n\n  return createConnector<Provider, Properties, PasskeyStorageItem>((config) => ({\n    id: 'passkeySmartWallet',\n    name: 'Passkey Smart Wallet',\n    type: passkeySmartWallet.type,\n    async connect({ chainId, isReconnecting, isRegistering = true } = {} as any) {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      let accounts: readonly string[] = [];\n      if (isReconnecting) {\n        accounts = await this.getAccounts().catch(() => []);\n      }\n\n      try {\n        if (!accounts?.length && !isReconnecting) {\n          const name = isRegistering ? registrationName?.() : undefined;\n          const requestedAccounts = await provider.request({\n            method: 'eth_requestAccounts',\n            params: [isRegistering, name],\n          });\n          accounts = requestedAccounts;\n        }\n\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this);\n          provider.on('chainChanged', chainChanged);\n        }\n\n        let currentChainId = await this.getChainId();\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch(() => {\n            return { id: currentChainId };\n          });\n          currentChainId = chain?.id ?? currentChainId;\n        }\n        return { accounts, chainId: currentChainId };\n      } catch (error: any) {\n        console.log('passkey connect error', error);\n        if (error.name === 'NotAllowedError') {\n          throw new UserRejectedRequestError(error);\n        }\n        throw error;\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider();\n      await config.storage?.removeItem('passkey.options');\n      // Manage EIP-1193 event listeners\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged);\n        chainChanged = undefined;\n      }\n    },\n    async getAccounts() {\n      const provider = await this.getProvider();\n      const accounts = await provider.request({\n        method: 'eth_accounts',\n      });\n      return accounts;\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      const chainId = await provider.request({\n        method: 'eth_chainId',\n      });\n      return Number(chainId);\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        walletProvider = new PasskeyProvider({ storage: config.storage! });\n      }\n\n      return walletProvider;\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts();\n        return !!accounts.length;\n      } catch {\n        return false;\n      }\n    },\n    async switchChain({ chainId }) {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      const chain = config.chains.find((x) => x.id === chainId);\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n\n      await provider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: numberToHex(chainId) }],\n      });\n\n      return chain;\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', { chainId });\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect');\n    },\n    isInstalled(): boolean {\n      return isUserVerifyingPlatformAuthenticatorAvailable ?? isPasskeySupported();\n    },\n    async getPasskeyOption() {\n      const provider = await this.getProvider();\n      return provider.getPasskeyOption();\n    },\n  }));\n}\n", "import type { PasskeyOption } from '@particle-network/aa';\nimport { ConnectorNotConnectedError, UserRejectedRequestError, type Storage } from '@particle-network/connector-core';\nimport type { AuthenticationResponseJSON } from '@simplewebauthn/typescript-types';\nimport Base64url from 'crypto-js/enc-base64url';\nimport Hex from 'crypto-js/enc-hex';\nimport Utf8 from 'crypto-js/enc-utf8';\nimport { EventEmitter } from 'eventemitter3';\nimport { InvalidParamsRpcError, encodeAbiParameters, isHex, parseAbiParameters, toHex } from 'viem';\nimport { getMessageSign, passkeysAuthentication, passkeysRegistration } from '../utils/passkeys';\n\ninterface RequestArguments {\n  method: string;\n  params?: any[];\n}\n\nexport type PasskeyStorageItem = {\n  'passkey.options': PasskeyOption;\n  'passkey.chainId': number;\n};\n\nconst defaultAddress = '0x0000000000000000000000000000000000000000';\n\nexport class PasskeyProvider {\n  #emitter: EventEmitter;\n  #storage: Storage<PasskeyStorageItem>;\n  isPasskey = true;\n\n  constructor({ storage }: { storage: Storage<PasskeyStorageItem> }) {\n    this.#emitter = new EventEmitter();\n    this.#storage = storage;\n  }\n\n  on(event: string, fn: any) {\n    this.#emitter.on(event, fn);\n    return this;\n  }\n\n  removeListener(event: string, fn: any) {\n    this.#emitter.removeListener(event, fn);\n    return this;\n  }\n\n  async request(payload: RequestArguments): Promise<any> {\n    if (payload.method === 'eth_accounts') {\n      const option = await this.getPasskeyOption();\n      if (option) {\n        return [defaultAddress];\n      }\n      return [];\n    } else if (payload.method === 'eth_requestAccounts') {\n      const option = await this.getPasskeyOption();\n      if (option) {\n        return [defaultAddress];\n      }\n\n      const isRegistering = payload.params?.[0];\n      if (isRegistering) {\n        const result = await passkeysRegistration(payload.params?.[1]);\n        await this.#storage.setItem('passkey.options', {\n          credentialId: result.rawId,\n          publicKey: result.response.publicKey,\n        });\n      } else {\n        const result = await passkeysAuthentication();\n        await this.#storage.setItem('passkey.options', {\n          credentialId: result.rawId,\n        });\n      }\n\n      return [defaultAddress];\n    } else if (payload.method === 'eth_chainId') {\n      const chainId = await this.#storage.getItem('passkey.chainId');\n      if (chainId) {\n        return `0x${chainId.toString(16)}`;\n      }\n      return '0x1';\n    } else if (payload.method === 'wallet_switchEthereumChain') {\n      const chainId = payload.params?.[0]?.chainId;\n      if (!chainId) {\n        throw new InvalidParamsRpcError(new Error('chainId not found.'));\n      }\n      await this.#storage.setItem('passkey.chainId', Number(chainId));\n      setTimeout(() => this.#emitter.emit('chainChanged', chainId), 0);\n      return;\n    } else if (payload.method === 'personal_sign') {\n      const message = payload.params?.[0];\n      if (!message) {\n        throw new InvalidParamsRpcError(new Error('message not found.'));\n      }\n      const signature = await this.signMessage(message);\n      return signature;\n    }\n\n    throw new Error(`The Passkey Provider does not support this method: ${payload.method}`);\n  }\n\n  async getPasskeyOption(): Promise<PasskeyOption | null> {\n    const option = await this.#storage.getItem('passkey.options');\n    return option;\n  }\n\n  async signMessage(message: string): Promise<string> {\n    const option = await this.getPasskeyOption();\n    if (!option) {\n      throw new ConnectorNotConnectedError();\n    }\n\n    let unsignMessage = message;\n    if (!isHex(message)) {\n      unsignMessage = toHex(message);\n    }\n\n    const challenge = Base64url.stringify(Hex.parse(unsignMessage.slice(2)));\n    console.log(`passkey sign, challenge: ${challenge}`);\n\n    let result: AuthenticationResponseJSON;\n    try {\n      result = await passkeysAuthentication({\n        credentialId: option.credentialId,\n        challenge,\n      });\n    } catch (error: any) {\n      if (error.name === 'NotAllowedError') {\n        throw new UserRejectedRequestError(error);\n      }\n      throw error;\n    }\n\n    const rawSignature = result.response.signature;\n    const authenticatorData = result.response.authenticatorData;\n    const clientDataJSON = result.response.clientDataJSON;\n\n    const [r, s] = getMessageSign(rawSignature);\n    const clientDataJSONString = Utf8.stringify(Base64url.parse(clientDataJSON));\n    console.log(`passkey sign, clientDataJSONString: ${clientDataJSONString}`);\n    const challengePos = clientDataJSONString.indexOf('challenge') - 1;\n    const typePos = clientDataJSONString.indexOf('type') - 1;\n    const authData = Hex.stringify(Base64url.parse(authenticatorData));\n    console.log(`passkey sign, authenticatorDataHex: 0x${authData}`);\n\n    const signature = encodeAbiParameters(\n      parseAbiParameters(\n        '(bytes authenticatorData, string clientDataJSON, uint256 challengeIndex, uint256 typeIndex, uint256 r, uint256 s)'\n      ),\n      [[`0x${authData}`, clientDataJSONString, BigInt(challengePos), BigInt(typePos), r, s] as any]\n    );\n    console.log(`passkey sign, signature: ${signature}`);\n    return signature;\n  }\n}\n", "import { uid } from '@particle-network/connector-core';\nimport { ECDSASigValue } from '@peculiar/asn1-ecc';\nimport { AsnParser } from '@peculiar/asn1-schema';\nimport { startAuthentication, startRegistration } from '@simplewebauthn/browser';\nimport type {\n  AuthenticationResponseJSON,\n  PublicKeyCredentialCreationOptionsJSON,\n  PublicKeyCredentialRequestOptionsJSON,\n  RegistrationResponseJSON,\n} from '@simplewebauthn/typescript-types';\nimport Base64url from 'crypto-js/enc-base64url';\nimport Hex from 'crypto-js/enc-hex';\nimport Utf8 from 'crypto-js/enc-utf8';\nimport SHA256 from 'crypto-js/sha256';\nimport { toBytes } from 'viem';\nimport { formatDate } from '.';\n\nexport const passkeysRegistration = async (name?: string): Promise<RegistrationResponseJSON> => {\n  const expiration = Math.floor(new Date().getTime() / 1000 + 300); // \u6709\u6548\u671F  300s\n  const challenge = Base64url.stringify(\n    Utf8.parse(`${SHA256(`${location.origin}:${expiration}`).toString()}:${expiration}`)\n  );\n  const id = uid();\n  const displayName = name || `Particle Smart Wallet ${formatDate(new Date())}`;\n  const options: PublicKeyCredentialCreationOptionsJSON = {\n    challenge,\n    rp: { name: 'Particle Smart Wallet', id: location.hostname },\n    user: {\n      id,\n      name: displayName,\n      displayName,\n    },\n    pubKeyCredParams: [\n      { alg: -7, type: 'public-key' }, // ES256\uFF0CECDSA with SHA-256 (\u5728\u692D\u5706\u66F2\u7EBF P-256 \u4E0A)\n    ],\n    timeout: 60000,\n    attestation: 'none',\n    excludeCredentials: [],\n    authenticatorSelection: {\n      residentKey: 'preferred',\n      userVerification: 'required',\n      requireResidentKey: false,\n    },\n    extensions: { credProps: true },\n  };\n\n  const result = await startRegistration(options);\n  console.log('passkey startRegistration', result);\n  return result;\n};\n\nexport const passkeysAuthentication = async (option?: {\n  credentialId: string;\n  challenge: string;\n}): Promise<AuthenticationResponseJSON> => {\n  const { credentialId, challenge } = option || {};\n  const expiration = Math.floor(new Date().getTime() / 1000 + 300); // \u6709\u6548\u671F  300s\n  const challengeValue =\n    challenge ||\n    Base64url.stringify(Utf8.parse(`${SHA256(`${location.origin}:${expiration}`).toString()}:${expiration}`));\n\n  const options: PublicKeyCredentialRequestOptionsJSON = {\n    challenge: challengeValue,\n    allowCredentials: credentialId\n      ? [\n          {\n            type: 'public-key',\n            id: credentialId,\n          },\n        ]\n      : undefined,\n    timeout: 60000,\n    userVerification: 'required',\n    extensions: undefined,\n    rpId: location.hostname,\n  };\n  const result = await startAuthentication(options);\n  console.log('passkey startAuthentication', result);\n  return result;\n};\n\nconst ellipticZZPoints = BigInt('0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551');\n\nexport function getMessageSign(signature: string): [bigint, bigint] {\n  // See https://github.dev/MasterKale/SimpleWebAuthn/blob/master/packages/server/src/helpers/iso/isoCrypto/verifyEC2.ts\n  // for extraction of the r and s bytes from the raw signature buffer\n  const hexSignature = Hex.stringify(Base64url.parse(signature));\n  const parsedSignature = AsnParser.parse(toBytes(`0x${hexSignature}`), ECDSASigValue);\n  let rBytes = new Uint8Array(parsedSignature.r);\n  let sBytes = new Uint8Array(parsedSignature.s);\n  if (shouldRemoveLeadingZero(rBytes)) {\n    rBytes = rBytes.slice(1);\n  }\n  if (shouldRemoveLeadingZero(sBytes)) {\n    sBytes = sBytes.slice(1);\n  }\n  // r and s values\n  const r = BigInt('0x' + Buffer.from(rBytes).toString('hex'));\n  let s = BigInt('0x' + Buffer.from(sBytes).toString('hex'));\n  if (s > ellipticZZPoints / 2n) {\n    s = ellipticZZPoints - s;\n  }\n  return [r, s];\n}\n\nfunction shouldRemoveLeadingZero(bytes: Uint8Array): boolean {\n  if (!bytes.length) {\n    return false;\n  }\n  return bytes[0] === 0x0 && (bytes[1]! & (1 << 7)) !== 0;\n}\n\nexport function isPasskeySupported(): boolean {\n  // Check if navigator.credentials.create exists\n  if (typeof window === 'undefined' || !navigator.credentials || typeof navigator.credentials.create !== 'function') {\n    return false;\n  }\n\n  // Check if PublicKeyCredential is supported\n  if (typeof window.PublicKeyCredential !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n", "export const formatDate = (date: Date): string => {\n  const year = date.getFullYear();\n  const month = date.getMonth() + 1; // getMonth() \u8FD4\u56DE 0-11\uFF0C\u9700\u8981\u52A0 1\n  const day = date.getDate();\n\n  return `${year}/${month}/${day}`;\n};\n", "import {\n  ChainNotConfiguredError,\n  ProviderNotFoundError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  createConnector,\n  numberToHex,\n  type AddEthereumChainParameter,\n  type Connector,\n  type Evaluate,\n  type ExactPartial,\n  type ProviderConnectInfo,\n  type ProviderRpcError,\n  type RpcError,\n} from '@particle-network/connector-core';\nimport type { EthereumProvider } from '@walletconnect/ethereum-provider';\n\ntype WalletConnectConnector = Connector & {\n  onDisplayUri(uri: string): void;\n  onSessionDelete(data: { topic: string }): void;\n};\n\ntype EthereumProviderOptions = Parameters<(typeof EthereumProvider)['init']>[0];\n\nexport type WalletConnectParameters = Evaluate<\n  {\n    /**\n     * If a new chain is added to a previously existing configured connector `chains`, this flag\n     * will determine if that chain should be considered as stale. A stale chain is a chain that\n     * WalletConnect has yet to establish a relationship with (e.g. the user has not approved or\n     * rejected the chain).\n     *\n     * This flag mainly affects the behavior when a wallet does not support dynamic chain authorization\n     * with WalletConnect v2.\n     *\n     * If `true` (default), the new chain will be treated as a stale chain. If the user\n     * has yet to establish a relationship (approved/rejected) with this chain in their WalletConnect\n     * session, the connector will disconnect upon the dapp auto-connecting, and the user will have to\n     * reconnect to the dapp (revalidate the chain) in order to approve the newly added chain.\n     * This is the default behavior to avoid an unexpected error upon switching chains which may\n     * be a confusing user experience (e.g. the user will not know they have to reconnect\n     * unless the dapp handles these types of errors).\n     *\n     * If `false`, the new chain will be treated as a potentially valid chain. This means that if the user\n     * has yet to establish a relationship with the chain in their WalletConnect session, wagmi will successfully\n     * auto-connect the user. This comes with the trade-off that the connector will throw an error\n     * when attempting to switch to the unapproved chain if the wallet does not support dynamic session updates.\n     * This may be useful in cases where a dapp constantly\n     * modifies their configured chains, and they do not want to disconnect the user upon\n     * auto-connecting. If the user decides to switch to the unapproved chain, it is important that the\n     * dapp handles this error and prompts the user to reconnect to the dapp in order to approve\n     * the newly added chain.\n     *\n     * @default true\n     */\n    isNewChainsStale?: boolean;\n\n    /**\n     * make projectId optional, and add a default value.\n     */\n    projectId?: string;\n  } & Omit<\n    EthereumProviderOptions,\n    | 'chains'\n    | 'events'\n    | 'optionalChains'\n    | 'optionalEvents'\n    | 'optionalMethods'\n    | 'methods'\n    | 'rpcMap'\n    | 'showQrModal'\n    | 'projectId'\n  > &\n    ExactPartial<Pick<EthereumProviderOptions, 'showQrModal'>>\n>;\n\nconst defaultProjectId = '673a283fa38457f23911103771ccc65d';\n\nwalletConnect.type = 'walletConnect' as const;\n\nexport function walletConnect(parameters: WalletConnectParameters) {\n  const isNewChainsStale = parameters.isNewChainsStale ?? true;\n\n  type Provider = Awaited<ReturnType<(typeof EthereumProvider)['init']>>;\n  type Properties = {\n    connect(parameters?: { chainId?: number; pairingTopic?: string }): Promise<{\n      accounts: readonly string[];\n      chainId: number;\n    }>;\n    getNamespaceChainsIds(): number[];\n    getRequestedChainsIds(): Promise<number[]>;\n    isChainsStale(): Promise<boolean>;\n    onConnect(connectInfo: ProviderConnectInfo): void;\n    onDisplayUri(uri: string): void;\n    onSessionDelete(data: { topic: string }): void;\n    setRequestedChainsIds(chains: number[]): void;\n    requestedChainsStorageKey: `${string}.requestedChains`;\n    projectId: string;\n  };\n\n  type StorageItem = {\n    [_ in Properties['requestedChainsStorageKey']]: number[];\n  };\n\n  let provider_: Provider | undefined;\n  let providerPromise: Promise<typeof provider_>;\n  const NAMESPACE = 'eip155';\n\n  let accountsChanged: WalletConnectConnector['onAccountsChanged'] | undefined;\n  let chainChanged: WalletConnectConnector['onChainChanged'] | undefined;\n  let connect: WalletConnectConnector['onConnect'] | undefined;\n  let displayUri: WalletConnectConnector['onDisplayUri'] | undefined;\n  let sessionDelete: WalletConnectConnector['onSessionDelete'] | undefined;\n  let disconnect: WalletConnectConnector['onDisconnect'] | undefined;\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    id: 'walletConnect',\n    name: 'WalletConnect',\n    type: walletConnect.type,\n    projectId: config['walletConnectProjectId'] || parameters.projectId || defaultProjectId,\n    async setup() {\n      const provider = await this.getProvider().catch(() => null);\n      if (!provider) return;\n      if (!connect) {\n        connect = this.onConnect.bind(this);\n        provider.on('connect', connect);\n      }\n      if (!sessionDelete) {\n        sessionDelete = this.onSessionDelete.bind(this);\n        provider.on('session_delete', sessionDelete);\n      }\n    },\n    async connect({ chainId, ...rest }) {\n      try {\n        const provider: Provider = await this.getProvider();\n        if (!provider) throw new ProviderNotFoundError();\n        if (!displayUri) {\n          displayUri = this.onDisplayUri;\n          provider.on('display_uri', displayUri);\n        }\n\n        let targetChainId = chainId;\n        if (!targetChainId) {\n          const state = (await config.storage?.getItem('state')) ?? {};\n          const isChainSupported = config.chains.some((x) => x.id === state.chainId);\n          if (isChainSupported) targetChainId = state.chainId;\n          else targetChainId = config.chains[0]?.id;\n        }\n        if (!targetChainId) throw new Error('No chains found on connector.');\n\n        const isChainsStale = await this.isChainsStale();\n        // If there is an active session with stale chains, disconnect current session.\n        if (provider.session && isChainsStale) await provider.disconnect();\n\n        // If there isn't an active session or chains are stale, connect.\n        if (!provider.session || isChainsStale) {\n          const optionalChains = config.chains\n            .filter((chain) => chain.id !== targetChainId)\n            .map((optionalChain) => optionalChain.id);\n          await provider.connect({\n            optionalChains: [targetChainId, ...optionalChains],\n            ...('pairingTopic' in rest ? { pairingTopic: rest.pairingTopic } : {}),\n          });\n\n          this.setRequestedChainsIds(config.chains.map((x) => x.id));\n        }\n\n        // If session exists and chains are authorized, enable provider for required chain\n        const accounts = await provider.enable();\n        const currentChainId = await this.getChainId();\n\n        if (displayUri) {\n          provider.removeListener('display_uri', displayUri);\n          displayUri = undefined;\n        }\n        if (connect) {\n          provider.removeListener('connect', connect);\n          connect = undefined;\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged!.bind(this);\n          provider.on('accountsChanged', accountsChanged);\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this);\n          provider.on('chainChanged', chainChanged);\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this);\n          provider.on('disconnect', disconnect);\n        }\n        if (!sessionDelete) {\n          sessionDelete = this.onSessionDelete.bind(this);\n          provider.on('session_delete', sessionDelete);\n        }\n\n        return { accounts, chainId: currentChainId };\n      } catch (error) {\n        if (/(user rejected|connection request reset)/i.test((error as ProviderRpcError)?.message)) {\n          throw new UserRejectedRequestError(error as Error);\n        }\n        throw error;\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider();\n      try {\n        await provider?.disconnect();\n      } catch (error) {\n        if (!/No matching key/i.test((error as Error).message)) throw error;\n      } finally {\n        if (chainChanged) {\n          provider?.removeListener('chainChanged', chainChanged);\n          chainChanged = undefined;\n        }\n        if (disconnect) {\n          provider?.removeListener('disconnect', disconnect);\n          disconnect = undefined;\n        }\n        if (!connect) {\n          connect = this.onConnect.bind(this);\n          provider?.on('connect', connect);\n        }\n        if (accountsChanged) {\n          provider?.removeListener('accountsChanged', accountsChanged);\n          accountsChanged = undefined;\n        }\n        if (sessionDelete) {\n          provider?.removeListener('session_delete', sessionDelete);\n          sessionDelete = undefined;\n        }\n\n        this.setRequestedChainsIds([]);\n      }\n    },\n    async getAccounts() {\n      const provider = await this.getProvider();\n      return provider.accounts;\n    },\n    async getProvider({ chainId } = {}) {\n      const pId = this.projectId;\n      async function initProvider() {\n        const optionalChains = config.chains.map((x) => x.id) as [number];\n        if (!optionalChains.length) return;\n        const { EthereumProvider } = await import('@walletconnect/ethereum-provider');\n        return await EthereumProvider.init({\n          ...parameters,\n          disableProviderPing: true,\n          optionalChains,\n          projectId: pId,\n          rpcMap: Object.fromEntries(config.chains.map((chain) => [chain.id, chain.rpcUrls.default.http[0]!])),\n          showQrModal: parameters.showQrModal ?? false,\n        });\n      }\n\n      if (!provider_) {\n        if (!providerPromise) providerPromise = initProvider();\n        provider_ = await providerPromise;\n        provider_?.events.setMaxListeners(Number.POSITIVE_INFINITY);\n      }\n      if (chainId) await this.switchChain?.({ chainId });\n      return provider_!;\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      return provider.chainId;\n    },\n    async isAuthorized() {\n      try {\n        const [accounts, provider] = await Promise.all([this.getAccounts(), this.getProvider()]);\n\n        // If an account does not exist on the session, then the connector is unauthorized.\n        if (!accounts.length) return false;\n\n        // If the chains are stale on the session, then the connector is unauthorized.\n        const isChainsStale = await this.isChainsStale();\n        if (isChainsStale && provider.session) {\n          await provider.disconnect().catch(() => {});\n          return false;\n        }\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const currentChainId = await this.getChainId();\n\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      const chain = config.chains.find((x) => x.id === chainId);\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n\n      if (currentChainId === chainId) {\n        return chain;\n      }\n\n      try {\n        await Promise.all([\n          new Promise<void>((resolve) => {\n            const listener = ({ chainId: currentChainId }: { chainId?: number }) => {\n              if (currentChainId === chainId) {\n                config.emitter.off('change', listener);\n                resolve();\n              }\n            };\n            config.emitter.on('change', listener);\n          }),\n          provider.request({\n            method: 'wallet_switchEthereumChain',\n            params: [{ chainId: numberToHex(chainId) }],\n          }),\n        ]);\n\n        const requestedChains = await this.getRequestedChainsIds();\n        this.setRequestedChainsIds([...requestedChains, chainId]);\n\n        return chain;\n      } catch (err) {\n        const error = err as RpcError;\n\n        if (/(user rejected)/i.test(error.message)) throw new UserRejectedRequestError(error);\n\n        // Indicates chain is not added to provider\n        try {\n          let blockExplorerUrls: string[] | undefined;\n          if (addEthereumChainParameter?.blockExplorerUrls)\n            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;\n          else blockExplorerUrls = chain.blockExplorers?.default.url ? [chain.blockExplorers?.default.url] : [];\n\n          let rpcUrls: readonly string[];\n          if (addEthereumChainParameter?.rpcUrls?.length) rpcUrls = addEthereumChainParameter.rpcUrls;\n          else rpcUrls = [chain.rpcUrls.default?.http[0] ?? ''];\n\n          const addEthereumChain = {\n            blockExplorerUrls,\n            chainId: numberToHex(chainId),\n            chainName: addEthereumChainParameter?.chainName ?? chain.name,\n            iconUrls: addEthereumChainParameter?.iconUrls,\n            nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,\n            rpcUrls,\n          } satisfies AddEthereumChainParameter;\n\n          await provider.request({\n            method: 'wallet_addEthereumChain',\n            params: [addEthereumChain],\n          });\n\n          const requestedChains = await this.getRequestedChainsIds();\n          this.setRequestedChainsIds([...requestedChains, chainId]);\n\n          return chain;\n        } catch (error) {\n          throw new UserRejectedRequestError(error as Error);\n        }\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect();\n      else\n        config.emitter.emit('change', {\n          accounts,\n        });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', { chainId });\n    },\n    async onConnect(connectInfo) {\n      const chainId = Number(connectInfo.chainId);\n      const accounts = await this.getAccounts();\n      config.emitter.emit('connect', { accounts, chainId });\n    },\n    async onDisconnect(_error) {\n      this.setRequestedChainsIds([]);\n      config.emitter.emit('disconnect');\n\n      const provider = await this.getProvider();\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged);\n        accountsChanged = undefined;\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged);\n        chainChanged = undefined;\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect);\n        disconnect = undefined;\n      }\n      if (sessionDelete) {\n        provider.removeListener('session_delete', sessionDelete);\n        sessionDelete = undefined;\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this);\n        provider.on('connect', connect);\n      }\n    },\n    onDisplayUri(uri) {\n      config.emitter.emit('message', { type: 'display_uri', data: uri });\n    },\n    onSessionDelete() {\n      this.onDisconnect();\n    },\n    getNamespaceChainsIds() {\n      if (!provider_) return [];\n      const chainIds = provider_.session?.namespaces[NAMESPACE]?.accounts?.map((account) =>\n        Number.parseInt(account.split(':')[1] || '')\n      );\n      return chainIds ?? [];\n    },\n    async getRequestedChainsIds() {\n      return (await config.storage?.getItem(this.requestedChainsStorageKey)) ?? [];\n    },\n    /**\n     * Checks if the target chains match the chains that were\n     * initially requested by the connector for the WalletConnect session.\n     * If there is a mismatch, this means that the chains on the connector\n     * are considered stale, and need to be revalidated at a later point (via\n     * connection).\n     *\n     * There may be a scenario where a dapp adds a chain to the\n     * connector later on, however, this chain will not have been approved or rejected\n     * by the wallet. In this case, the chain is considered stale.\n     */\n    async isChainsStale() {\n      if (!isNewChainsStale) return false;\n\n      const connectorChains = config.chains.map((x) => x.id);\n      const namespaceChains = this.getNamespaceChainsIds();\n      if (namespaceChains.length && !namespaceChains.some((id) => connectorChains.includes(id))) return false;\n\n      const requestedChains = await this.getRequestedChainsIds();\n      return !connectorChains.every((id) => requestedChains.includes(id));\n    },\n    async setRequestedChainsIds(chains) {\n      await config.storage?.setItem(this.requestedChainsStorageKey, chains);\n    },\n    get requestedChainsStorageKey() {\n      return `${this.id}.requestedChains` as Properties['requestedChainsStorageKey'];\n    },\n  }));\n}\n", "import type { CreateConnectorFn } from '@particle-network/connector-core';\nimport { coinbaseWallet } from './coinbaseWallet';\nimport { injected } from './injected';\nimport { walletConnect } from './walletConnect';\n\ntype DefaultConnectorsProps = {\n  metadata?: {\n    name: string;\n    icon?: string;\n    description?: string;\n    url?: string;\n  };\n  walletConnectProjectId?: string;\n};\n\nexport const defaultConnectorFns = ({\n  metadata,\n  walletConnectProjectId,\n}: DefaultConnectorsProps = {}): CreateConnectorFn[] => {\n  const hasAllAppData = metadata && metadata.name && metadata.icon && metadata.description && metadata.url;\n  const connectors: CreateConnectorFn[] = [];\n\n  connectors.push(injected({ target: 'metaMask' }));\n  connectors.push(injected({ target: 'trustWallet' }));\n  connectors.push(injected({ target: 'bitKeep' }));\n  connectors.push(injected({ target: 'okxWallet' }));\n  connectors.push(injected({ target: 'phantom' }));\n\n  if (metadata) {\n    connectors.push(\n      coinbaseWallet({\n        appName: metadata.name,\n        appLogoUrl: metadata.icon,\n      })\n    );\n  }\n\n  connectors.push(\n    walletConnect({\n      showQrModal: false,\n      projectId: walletConnectProjectId,\n      metadata: hasAllAppData\n        ? {\n            name: metadata.name,\n            description: metadata.description!,\n            url: metadata.url!,\n            icons: [metadata.icon!],\n          }\n        : undefined,\n    })\n  );\n\n  return connectors;\n};\n", "import {\n  ChainNotConfiguredError,\n  createEmitter,\n  createWalletConnector,\n  isEVMChain,\n  type ChainType,\n  type ClientType,\n  type Connector,\n  type ConnectorEventMap,\n  type CreateConnectorFn,\n  type EVMChain,\n  type WalletConnectorsOption,\n} from '@particle-network/connector-core';\nimport { createStore as createMipd, type EIP6963ProviderDetail } from 'mipd';\nimport type { Chain } from 'viem/chains';\nimport { createStore } from 'zustand/vanilla';\nimport { defaultConnectorFns as defaultEVMConnectorFns } from './defaultConnectorFns';\nimport { getPublicClient } from './getPublicClient';\nimport { injected } from './injected';\nimport { walletConnect } from './walletConnect';\n\ntype EVMConnectorsOption = WalletConnectorsOption;\n\nexport type WalletParameters = {\n  metadata?: {\n    name: string;\n    icon?: string;\n    description?: string;\n    url?: string;\n  };\n  walletConnectProjectId?: string;\n  connectorFns?: CreateConnectorFn[];\n  multiInjectedProviderDiscovery?: boolean;\n};\n\nevmWalletConnectors.type = 'evmWallet' as const;\nexport function evmWalletConnectors(parameters: WalletParameters = {}) {\n  const { metadata, walletConnectProjectId, connectorFns, multiInjectedProviderDiscovery = true } = parameters;\n  const defaultConnectorFns =\n    connectorFns ??\n    defaultEVMConnectorFns({\n      metadata,\n      walletConnectProjectId,\n    });\n\n  type Properties = {\n    w3mConnector?: CreateConnectorFn;\n  };\n\n  return createWalletConnector<EVMConnectorsOption, Properties>((options) => {\n    const { ...rest } = options;\n\n    const allChains = rest.chains.filter(isEVMChain) as [Chain, ...Chain[]];\n    if (allChains.length == 0) {\n      throw new Error('Please add EVM chains in Connectkit options.');\n    }\n    const mipd = typeof window !== 'undefined' && multiInjectedProviderDiscovery ? createMipd() : undefined;\n    const chains = createStore(() => allChains);\n\n    let wcProjectId = null;\n\n    function providerDetailToConnector(providerDetail: EIP6963ProviderDetail) {\n      const { info } = providerDetail;\n      const provider = providerDetail.provider;\n      return injected({ target: { ...info, id: info.rdns, provider } });\n    }\n\n    function setup(connectorFn: CreateConnectorFn): Connector {\n      // Set up emitter and add to connector so they are \"linked\" together.\n      const emitter = createEmitter<ConnectorEventMap>();\n      const config = { emitter, chains: chains.getState(), storage: rest.storage, walletConnectProjectId };\n      const connector = {\n        ...connectorFn(config),\n        emitter,\n        uid: emitter.uid,\n        chainType: 'evm' as const,\n        walletConnectorType: evmWalletConnectors.type,\n      };\n\n      connector.setup?.();\n      if (connector.type === 'walletConnect') {\n        wcProjectId = connector['projectId'];\n      }\n      return connector;\n    }\n\n    const registeredProvider =\n      mipd\n        ?.getProviders()\n        .filter((details) => details.info.rdns !== 'network.particle')\n        .map(providerDetailToConnector) ?? [];\n\n    const connectors = createStore(() => [...defaultConnectorFns, ...registeredProvider].map(setup));\n\n    let _w3mConnector: CreateConnectorFn | undefined;\n    if (wcProjectId) {\n      console.log('walletConnectProjectId', wcProjectId);\n      const hasAllAppData = metadata && metadata.name && metadata.icon && metadata.description && metadata.url;\n      _w3mConnector = walletConnect({\n        showQrModal: true,\n        projectId: wcProjectId,\n        metadata: hasAllAppData\n          ? {\n              name: metadata.name,\n              description: metadata.description!,\n              url: metadata.url!,\n              icons: [metadata.icon!],\n            }\n          : undefined,\n      });\n    }\n\n    // EIP-6963 subscribe for new wallet providers\n    mipd?.subscribe((providerDetails) => {\n      const currentConnectorIds = new Map();\n      for (const connector of connectors.getState()) {\n        currentConnectorIds.set(connector.id, true);\n      }\n\n      const newConnectors: Connector[] = [];\n      for (const providerDetail of providerDetails) {\n        if (providerDetail.info.rdns === 'network.particle') {\n          // ignore particle wallet\n          continue;\n        }\n        const connector = setup(providerDetailToConnector(providerDetail));\n        if (currentConnectorIds.has(connector.id)) continue;\n        console.log('EIP-6963 provider-', providerDetail);\n        newConnectors.push(connector);\n      }\n\n      if (newConnectors.length) {\n        connectors.setState((x) => [...x, ...newConnectors], true);\n      }\n    });\n\n    function getClient<chainType extends ChainType = EVMChain>(chainId: number): ClientType<chainType> {\n      const chain = chains.getState().find((chain) => chain.id === chainId);\n      if (!chain) {\n        throw new ChainNotConfiguredError();\n      }\n      return getPublicClient(chain) as ClientType<chainType>;\n    }\n\n    return {\n      get type() {\n        return evmWalletConnectors.type;\n      },\n      get chains() {\n        return chains.getState();\n      },\n      get connectors() {\n        return connectors.getState();\n      },\n      store: connectors,\n      getClient,\n      w3mConnector: _w3mConnector,\n      _internal: {\n        connectors: {\n          setup,\n        },\n      },\n    };\n  });\n}\n", "import { createPublicClient, http, type Chain, type PublicClient } from 'viem';\n\nconst clients = new Map<number, PublicClient>();\n\nexport function getPublicClient(chain: Chain): PublicClient {\n  {\n    const client = clients.get(chain.id);\n    if (client) return client;\n  }\n\n  const client = createPublicClient({\n    chain,\n    transport: http(),\n  });\n  clients.set(chain.id, client);\n\n  return client;\n}\n", "export const version = '1.0.8';\n"],
  "mappings": "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",
  "names": ["chain", "error", "ChainNotConfiguredError", "SwitchChainError", "UserRejectedRequestError", "createConnector", "numberToHex", "window", "provider", "error", "ChainNotConfiguredError", "ProviderNotFoundError", "SwitchChainError", "UserRejectedRequestError", "createConnector", "numberToHex", "UserRejectedRequestError", "Base64url", "Hex", "Utf8", "Base64url", "Hex", "UserRejectedRequestError", "Utf8", "createConnector", "ProviderNotFoundError", "UserRejectedRequestError", "SwitchChainError", "ChainNotConfiguredError", "numberToHex", "ChainNotConfiguredError", "ProviderNotFoundError", "SwitchChainError", "UserRejectedRequestError", "createConnector", "numberToHex", "currentChainId", "error", "ChainNotConfiguredError", "client", "defaultConnectorFns", "chain", "ChainNotConfiguredError"]
}
