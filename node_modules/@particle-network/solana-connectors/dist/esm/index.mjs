// src/injected.ts
import {
  ChainNotConfiguredError,
  ProviderNotFoundError,
  SwitchChainError,
  UserRejectedRequestError,
  WalletAccountError,
  createConnector
} from "@particle-network/connector-core";
import { PublicKey } from "@solana/web3.js";

// src/utils.ts
var isConnected = (provider) => {
  if (provider && typeof provider.isConnected === "boolean") {
    return provider.isConnected;
  }
  return Boolean(provider == null ? void 0 : provider.publicKey);
};

// src/injected.ts
var targetMap = {
  coinbaseWallet: {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    provider(window2) {
      if (typeof window2 !== "undefined") {
        return window2 == null ? void 0 : window2.coinbaseSolana;
      }
      return void 0;
    }
  },
  bitKeep: {
    id: "bitKeep",
    name: "Bitget",
    provider(window2) {
      var _a, _b, _c;
      if (typeof window2 !== "undefined" && ((_b = (_a = window2.bitkeep) == null ? void 0 : _a.solana) == null ? void 0 : _b.isBitKeep)) {
        return (_c = window2.bitkeep) == null ? void 0 : _c.solana;
      }
    }
  },
  phantom: {
    id: "phantom",
    name: "Phantom",
    provider(window2) {
      var _a, _b, _c;
      if (typeof window2 !== "undefined" && ((_b = (_a = window2.phantom) == null ? void 0 : _a.solana) == null ? void 0 : _b.isPhantom)) {
        return (_c = window2.phantom) == null ? void 0 : _c.solana;
      }
    }
  },
  trustWallet: {
    id: "trustWallet",
    name: "Trust Wallet",
    provider(window2) {
      var _a, _b, _c;
      if (typeof window2 !== "undefined" && ((_b = (_a = window2.trustwallet) == null ? void 0 : _a.solana) == null ? void 0 : _b.isTrust)) {
        return (_c = window2.trustwallet) == null ? void 0 : _c.solana;
      }
    }
  },
  okxWallet: {
    id: "okxWallet",
    name: "OKX Wallet",
    provider(window2) {
      var _a, _b, _c;
      if (typeof window2 !== "undefined" && ((_b = (_a = window2.okxwallet) == null ? void 0 : _a.solana) == null ? void 0 : _b.isOkxWallet)) {
        return (_c = window2.okxwallet) == null ? void 0 : _c.solana;
      }
    }
  },
  braveWallet: {
    id: "braveWallet",
    name: "Brave Wallet",
    provider(window2) {
      var _a;
      if (typeof window2 !== "undefined" && ((_a = window2.braveSolana) == null ? void 0 : _a.isBraveWallet)) {
        return window2.braveSolana;
      }
    }
  }
};
injected.type = "injected";
function injected(parameters) {
  const { unstableShimAsyncInject } = parameters;
  function getTarget() {
    const target = parameters.target;
    if (typeof target === "function") {
      const result = target();
      if (result)
        return result;
    }
    if (typeof target === "object")
      return target;
    if (typeof target === "string" && targetMap[target])
      return targetMap[target];
    throw new Error("target not found.");
  }
  let accountChanged;
  let disconnect;
  return createConnector((config) => ({
    get icon() {
      return getTarget().icon;
    },
    get id() {
      return `solana_${getTarget().id}`;
    },
    get name() {
      return getTarget().name;
    },
    type: injected.type,
    async connect({ chainId, isReconnecting } = {}) {
      var _a, _b, _c;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      let accounts = [];
      if (isReconnecting) {
        const connected = await ((_a = config.storage) == null ? void 0 : _a.getItem(`${this.id}.injected.connected`));
        if (connected) {
          if (!isConnected(provider)) {
            await provider.connect();
          }
          if (!provider.publicKey)
            throw new WalletAccountError(this.id);
        }
        accounts = await this.getAccounts().catch(() => []);
      }
      try {
        if (!(accounts == null ? void 0 : accounts.length) && !isReconnecting) {
          if (!isConnected(provider)) {
            await provider.connect();
          }
          if (!provider.publicKey)
            throw new WalletAccountError(this.id);
          accounts = [provider.publicKey.toBase58()];
        }
        if (!accountChanged) {
          accountChanged = this.onAccountChanged.bind(this);
          provider.on("accountChanged", accountChanged);
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (_b = chain == null ? void 0 : chain.id) != null ? _b : currentChainId;
        }
        await ((_c = config.storage) == null ? void 0 : _c.setItem(`${this.id}.injected.connected`, true));
        if (provider.publicKey) {
          this.publicKey = new PublicKey(provider.publicKey.toBytes());
        }
        return { accounts, chainId: currentChainId };
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      var _a;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
      try {
        await provider.disconnect();
      } catch {
      }
      await ((_a = config.storage) == null ? void 0 : _a.removeItem(`${this.id}.injected.connected`));
      this.publicKey = void 0;
    },
    async getAccounts() {
      var _a;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      if (this.publicKey) {
        return [this.publicKey.toBase58()];
      }
      const connected = await ((_a = config.storage) == null ? void 0 : _a.getItem(`${this.id}.injected.connected`));
      if (connected) {
        if (!isConnected(provider)) {
          await provider.connect();
        }
        if (provider.publicKey) {
          this.publicKey = new PublicKey(provider.publicKey.toBytes());
          return [this.publicKey.toBase58()];
        }
      }
      return [];
    },
    async getChainId() {
      var _a;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const chainId = await ((_a = config.storage) == null ? void 0 : _a.getItem(`${this.id}.injected.chainId`));
      if (chainId && config.chains.find((chain) => chain.id === Number(chainId))) {
        return Number(chainId);
      }
      return config.chains[0].id;
    },
    async getProvider() {
      if (typeof window === "undefined")
        return void 0;
      const target = getTarget();
      const provider = target.provider(window);
      return provider;
    },
    async isAuthorized() {
      var _a;
      try {
        let provider = await this.getProvider();
        if (!provider) {
          if (unstableShimAsyncInject !== void 0 && unstableShimAsyncInject !== false) {
            const handleProvider = async () => {
              const provider2 = await this.getProvider();
              return provider2;
            };
            const timeout = typeof unstableShimAsyncInject === "number" ? unstableShimAsyncInject : 1e3;
            provider = await new Promise((resolve) => setTimeout(() => resolve(handleProvider()), timeout));
            if (!provider) {
              throw new ProviderNotFoundError();
            }
          } else {
            throw new ProviderNotFoundError();
          }
        }
        const connected = await ((_a = config.storage) == null ? void 0 : _a.getItem(`${this.id}.injected.connected`));
        return Boolean(connected);
      } catch {
        return false;
      }
    },
    async switchChain({ chainId }) {
      var _a;
      const chain = config.chains.find((chain2) => chain2.id === chainId);
      if (!chain) {
        throw new SwitchChainError(new ChainNotConfiguredError());
      }
      await ((_a = config.storage) == null ? void 0 : _a.setItem(`${this.id}.injected.chainId`, chainId));
      config.emitter.emit("change", { chainId });
      return chain;
    },
    async onAccountChanged(publicKey) {
      if (!publicKey) {
        this.publicKey = void 0;
        this.onDisconnect();
      } else {
        this.publicKey = new PublicKey(publicKey.toBytes());
        config.emitter.emit("change", {
          accounts: [this.publicKey.toBase58()]
        });
      }
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect() {
      var _a;
      const provider = await this.getProvider();
      config.emitter.emit("disconnect");
      if (provider) {
        if (disconnect) {
          provider.removeListener("disconnect", disconnect);
          disconnect = void 0;
        }
      }
      this.publicKey = void 0;
      await ((_a = config.storage) == null ? void 0 : _a.removeItem(`${this.id}.injected.connected`));
    },
    isInstalled() {
      if (typeof window === "undefined")
        return false;
      const target = getTarget();
      const provider = target.provider(window);
      return Boolean(provider);
    }
  }));
}

// src/defaultConnectorFns.ts
var defaultConnectorFns = () => {
  const connectors = [];
  connectors.push(injected({ target: "phantom" }));
  connectors.push(injected({ target: "coinbaseWallet" }));
  connectors.push(injected({ target: "okxWallet" }));
  connectors.push(injected({ target: "bitKeep" }));
  connectors.push(injected({ target: "trustWallet" }));
  return connectors;
};

// src/store.ts
import {
  ChainNotConfiguredError as ChainNotConfiguredError2,
  createEmitter,
  createWalletConnector,
  isSolanaChain
} from "@particle-network/connector-core";
import { createStore } from "zustand/vanilla";

// src/getConnection.ts
import { Connection } from "@solana/web3.js";
var clients = /* @__PURE__ */ new Map();
function getConnection(chain) {
  {
    const client2 = clients.get(chain.id);
    if (client2)
      return client2;
  }
  const client = new Connection(chain.rpcUrls.default.http[0]);
  clients.set(chain.id, client);
  return client;
}

// src/store.ts
solanaWalletConnectors.type = "solanaWallet";
function solanaWalletConnectors(parameters = {}) {
  const { connectorFns } = parameters;
  const defaultConnectorFns2 = connectorFns != null ? connectorFns : defaultConnectorFns();
  return createWalletConnector((options) => {
    const { ...rest } = options;
    const allChains = rest.chains.filter(isSolanaChain);
    if (allChains.length == 0) {
      throw new Error("Please add Solana chains in Connectkit options.");
    }
    const chains = createStore(() => allChains);
    function setup(connectorFn) {
      var _a;
      const emitter = createEmitter();
      const connector = {
        ...connectorFn({ emitter, chains: chains.getState(), storage: rest.storage }),
        emitter,
        uid: emitter.uid,
        chainType: "solana",
        walletConnectorType: solanaWalletConnectors.type
      };
      (_a = connector.setup) == null ? void 0 : _a.call(connector);
      return connector;
    }
    const connectors = createStore(() => [...defaultConnectorFns2].map(setup));
    function getClient(chainId) {
      const chain = chains.getState().find((chain2) => chain2.id === chainId);
      if (!chain) {
        throw new ChainNotConfiguredError2();
      }
      return getConnection(chain);
    }
    return {
      get type() {
        return solanaWalletConnectors.type;
      },
      get chains() {
        return chains.getState();
      },
      get connectors() {
        return connectors.getState();
      },
      store: connectors,
      getClient,
      _internal: {
        connectors: {
          setup
        }
      }
    };
  });
}

// src/version.ts
var version = "1.0.1";
export {
  defaultConnectorFns,
  injected,
  solanaWalletConnectors,
  version
};
//# sourceMappingURL=index.mjs.map
