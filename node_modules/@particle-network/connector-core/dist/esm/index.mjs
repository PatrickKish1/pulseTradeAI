import {
  __publicField,
  defaultChainIcon,
  getChain,
  getChainIcon,
  getChainType,
  isEVMChain,
  isSolanaChain
} from "./chunk-NJRWNJ3W.mjs";

// src/createConnector.ts
function createConnector(createConnectorFn) {
  return createConnectorFn;
}
function createWalletConnector(createWalletConnectorFn) {
  return createWalletConnectorFn;
}

// src/createEmitter.ts
import { EventEmitter } from "eventemitter3";

// src/utils/uid.ts
var size = 256;
var index = size;
var buffer;
function uid(length = 11) {
  if (!buffer || index + length > size * 2) {
    buffer = "";
    index = 0;
    for (let i = 0; i < size; i++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer.substring(index, index++ + length);
}

// src/createEmitter.ts
var Emitter = class {
  constructor(uid2) {
    this.uid = uid2;
    __publicField(this, "_emitter", new EventEmitter());
  }
  on(eventName, fn) {
    this._emitter.on(eventName, fn);
  }
  once(eventName, fn) {
    this._emitter.once(eventName, fn);
  }
  off(eventName, fn) {
    this._emitter.off(eventName, fn);
  }
  emit(eventName, ...params) {
    const data = params[0];
    this._emitter.emit(eventName, { uid: this.uid, ...data });
  }
  listenerCount(eventName) {
    return this._emitter.listenerCount(eventName);
  }
};
function createEmitter() {
  return new Emitter(uid());
}

// src/utils/deserialize.ts
function deserialize(value, reviver) {
  return JSON.parse(value, (key, value_) => {
    let value2 = value_;
    if (value2?.__type === "bigint")
      value2 = BigInt(value2.value);
    if (value2?.__type === "Map")
      value2 = new Map(value2.value);
    return reviver?.(key, value2) ?? value2;
  });
}

// src/utils/serialize.ts
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join(".") || ".";
}
function getCutoff(array, value) {
  const { length } = array;
  for (let index2 = 0; index2 < length; ++index2) {
    if (array[index2] === value) {
      return index2 + 1;
    }
  }
  return 0;
}
function createReplacer(replacer, circularReplacer) {
  const hasReplacer = typeof replacer === "function";
  const hasCircularReplacer = typeof circularReplacer === "function";
  const cache = [];
  const keys = [];
  return function replace(key, value) {
    if (typeof value === "object") {
      if (cache.length) {
        const thisCutoff = getCutoff(cache, this);
        if (thisCutoff === 0) {
          cache[cache.length] = this;
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }
        keys[keys.length] = key;
        const valueCutoff = getCutoff(cache, value);
        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;
        }
      } else {
        cache[0] = value;
        keys[0] = key;
      }
    }
    return hasReplacer ? replacer.call(this, key, value) : value;
  };
}
function serialize(value, replacer, indent, circularReplacer) {
  return JSON.stringify(
    value,
    createReplacer((key, value_) => {
      let value2 = value_;
      if (typeof value2 === "bigint")
        value2 = { __type: "bigint", value: value_.toString() };
      if (value2 instanceof Map)
        value2 = { __type: "Map", value: Array.from(value_.entries()) };
      return replacer?.(key, value2) ?? value2;
    }, circularReplacer),
    indent ?? void 0
  );
}

// src/createStorage.ts
function createStorage(parameters) {
  const {
    deserialize: deserialize2 = deserialize,
    key: prefix = "particle-connectkit",
    serialize: serialize2 = serialize,
    storage = noopStorage
  } = parameters;
  function unwrap(value) {
    if (value instanceof Promise)
      return value.then((x) => x).catch(() => null);
    return value;
  }
  return {
    ...storage,
    key: prefix,
    async getItem(key, defaultValue) {
      const value = storage.getItem(`${prefix}.${key}`);
      const unwrapped = await unwrap(value);
      if (unwrapped)
        return deserialize2(unwrapped) ?? null;
      return defaultValue ?? null;
    },
    async setItem(key, value) {
      const storageKey = `${prefix}.${key}`;
      if (value === null)
        await unwrap(storage.removeItem(storageKey));
      else
        await unwrap(storage.setItem(storageKey, serialize2(value)));
    },
    async removeItem(key) {
      await unwrap(storage.removeItem(`${prefix}.${key}`));
    }
  };
}
var noopStorage = {
  getItem: () => null,
  setItem: () => {
  },
  removeItem: () => {
  }
};

// src/version.ts
var version = "1.0.1";

// src/errors/base.ts
var BaseError = class extends Error {
  constructor(shortMessage, options = {}) {
    super();
    __publicField(this, "details");
    __publicField(this, "metaMessages");
    __publicField(this, "shortMessage");
    __publicField(this, "name", "ConnectorCoreError");
    const details = options.cause instanceof BaseError ? options.cause.details : options.cause?.message ? options.cause.message : options.details;
    this.message = [
      shortMessage || "An error occurred.",
      "",
      ...options.metaMessages ? [...options.metaMessages, ""] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${this.version}`
    ].join("\n");
    if (options.cause)
      this.cause = options.cause;
    this.details = details;
    this.metaMessages = options.metaMessages;
    this.shortMessage = shortMessage;
  }
  get version() {
    return version;
  }
};

// src/errors/config.ts
var ChainNotConfiguredError = class extends BaseError {
  constructor() {
    super("Chain not configured.");
    __publicField(this, "name", "ChainNotConfiguredError");
  }
};
var ConnectorAlreadyConnectedError = class extends BaseError {
  constructor() {
    super("Connector already connected.");
    __publicField(this, "name", "ConnectorAlreadyConnectedError");
  }
};
var ConnectorNotConnectedError = class extends BaseError {
  constructor() {
    super("Connector not connected.");
    __publicField(this, "name", "ConnectorNotConnectedError");
  }
};
var ConnectorNotFoundError = class extends BaseError {
  constructor() {
    super("Connector not found.");
    __publicField(this, "name", "ConnectorNotFoundError");
  }
};
var ConnectorAccountNotFoundError = class extends BaseError {
  constructor({ address, connector }) {
    super(`Account "${address}" not found for connector "${connector.name}".`);
    __publicField(this, "name", "ConnectorAccountNotFoundError");
  }
};

// src/errors/connector.ts
var ProviderNotFoundError = class extends BaseError {
  constructor() {
    super("Provider not found.");
    __publicField(this, "name", "ProviderNotFoundError");
  }
};
var SwitchChainNotSupportedError = class extends BaseError {
  constructor({ connector }) {
    super(`"${connector.name}" does not support programmatic chain switching.`);
    __publicField(this, "name", "SwitchChainNotSupportedError");
  }
};
var WalletAccountError = class extends BaseError {
  constructor(id) {
    super(`"${id}" wallet account error.`);
    __publicField(this, "name", "WalletAccountError");
  }
};
var ChainTypeError = class extends BaseError {
  constructor() {
    super("Chain Type Error.");
    __publicField(this, "name", "ChainTypeError");
  }
};

// src/errors/rpc.ts
var unknownErrorCode = -1;
var RpcError = class extends BaseError {
  constructor(cause, { code, metaMessages, shortMessage }) {
    super(shortMessage, {
      cause,
      metaMessages: metaMessages || cause?.metaMessages
    });
    __publicField(this, "name", "RpcError");
    __publicField(this, "code");
    this.name = cause.name;
    this.code = cause.code || code || unknownErrorCode;
  }
};
var ProviderRpcError = class extends RpcError {
  constructor(cause, options) {
    super(cause, options);
    __publicField(this, "name", "ProviderRpcError");
    __publicField(this, "data");
    this.data = options.data;
  }
};
var _UserRejectedRequestError = class extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: _UserRejectedRequestError.code,
      shortMessage: "User rejected the request."
    });
    __publicField(this, "name", "UserRejectedRequestError");
  }
};
var UserRejectedRequestError = _UserRejectedRequestError;
__publicField(UserRejectedRequestError, "code", 4001);
var _UnauthorizedProviderError = class extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: _UnauthorizedProviderError.code,
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
    __publicField(this, "name", "UnauthorizedProviderError");
  }
};
var UnauthorizedProviderError = _UnauthorizedProviderError;
__publicField(UnauthorizedProviderError, "code", 4100);
var _UnsupportedProviderMethodError = class extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: _UnsupportedProviderMethodError.code,
      shortMessage: "The Provider does not support the requested method."
    });
    __publicField(this, "name", "UnsupportedProviderMethodError");
  }
};
var UnsupportedProviderMethodError = _UnsupportedProviderMethodError;
__publicField(UnsupportedProviderMethodError, "code", 4200);
var _ProviderDisconnectedError = class extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: _ProviderDisconnectedError.code,
      shortMessage: "The Provider is disconnected from all chains."
    });
    __publicField(this, "name", "ProviderDisconnectedError");
  }
};
var ProviderDisconnectedError = _ProviderDisconnectedError;
__publicField(ProviderDisconnectedError, "code", 4900);
var _ChainDisconnectedError = class extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: _ChainDisconnectedError.code,
      shortMessage: "The Provider is not connected to the requested chain."
    });
    __publicField(this, "name", "ChainDisconnectedError");
  }
};
var ChainDisconnectedError = _ChainDisconnectedError;
__publicField(ChainDisconnectedError, "code", 4901);
var _SwitchChainError = class extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: _SwitchChainError.code,
      shortMessage: "An error occurred when attempting to switch chain."
    });
    __publicField(this, "name", "SwitchChainError");
  }
};
var SwitchChainError = _SwitchChainError;
__publicField(SwitchChainError, "code", 4902);
var UnknownRpcError = class extends RpcError {
  constructor(cause) {
    super(cause, {
      shortMessage: "An unknown RPC error occurred."
    });
    __publicField(this, "name", "UnknownRpcError");
  }
};

// src/utils/solana.ts
function isVersionedTransaction(transaction) {
  return "version" in transaction;
}
var sendSolanaTransaction = async (provider, transaction, connection, options = {}) => {
  if (!isVersionedTransaction(transaction)) {
    transaction.feePayer = transaction.feePayer || provider.publicKey;
    transaction.recentBlockhash = transaction.recentBlockhash || (await connection.getLatestBlockhash({
      commitment: options.preflightCommitment,
      minContextSlot: options.minContextSlot
    })).blockhash;
  }
  options.preflightCommitment = options.preflightCommitment || connection.commitment;
  const signedTx = await provider.signTransaction(transaction);
  const signature = await connection.sendRawTransaction(signedTx.serialize(), options);
  return { signature };
};

// src/utils/index.ts
var numberToHex = (value) => {
  return `0x${value.toString(16)}`;
};
export {
  BaseError,
  ChainDisconnectedError,
  ChainNotConfiguredError,
  ChainTypeError,
  ConnectorAccountNotFoundError,
  ConnectorAlreadyConnectedError,
  ConnectorNotConnectedError,
  ConnectorNotFoundError,
  Emitter,
  ProviderDisconnectedError,
  ProviderNotFoundError,
  ProviderRpcError,
  RpcError,
  SwitchChainError,
  SwitchChainNotSupportedError,
  UnauthorizedProviderError,
  UnknownRpcError,
  UnsupportedProviderMethodError,
  UserRejectedRequestError,
  WalletAccountError,
  createConnector,
  createEmitter,
  createStorage,
  createWalletConnector,
  defaultChainIcon,
  getChain,
  getChainIcon,
  getChainType,
  isEVMChain,
  isSolanaChain,
  isVersionedTransaction,
  noopStorage,
  numberToHex,
  sendSolanaTransaction,
  uid,
  version
};
//# sourceMappingURL=index.mjs.map
