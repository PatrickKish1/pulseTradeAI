/** Combines members of an intersection into a readable type. */
export type Evaluate<type> = {
    [key in keyof type]: type[key];
} & unknown;
/**
 * Makes all properties of an object optional.
 *
 * Compatible with [`exactOptionalPropertyTypes`](https://www.typescriptlang.org/tsconfig#exactOptionalPropertyTypes).
 */
export type ExactPartial<type> = {
    [key in keyof type]?: type[key] | undefined;
};
/** Checks if {@link type} can be narrowed further than {@link type2} */
export type IsNarrowable<type, type2> = IsUnknown<type> extends true ? false : undefined extends type ? false : IsNever<(type extends type2 ? true : false) & (type2 extends type ? false : true)> extends true ? false : true;
/**
 * @internal
 * Checks if {@link type} is `never`
 */
export type IsNever<type> = [type] extends [never] ? true : false;
/**
 * @internal
 * Checks if {@link type} is `unknown`
 */
export type IsUnknown<type> = unknown extends type ? true : false;
/** Merges two object types into new type  */
export type Merge<obj1, obj2> = Evaluate<LooseOmit<obj1, keyof obj2 extends infer key extends string ? key : never> & obj2>;
/** Removes `readonly` from all properties of an object. */
export type Mutable<type extends object> = {
    -readonly [key in keyof type]: type[key];
};
/** Makes objects destructurable. */
export type OneOf<union extends object, keys extends KeyofUnion<union> = KeyofUnion<union>> = union extends infer Item ? Evaluate<Item & {
    [K in Exclude<keys, keyof Item>]?: undefined;
}> : never;
type KeyofUnion<type> = type extends type ? keyof type : never;
/** Loose version of {@link Omit} */
export type LooseOmit<type, keys extends string> = Pick<type, Exclude<keyof type, keys>>;
export type UnionEvaluate<type> = type extends object ? Evaluate<type> : type;
export type UnionOmit<type, keys extends keyof type> = type extends any ? Omit<type, keys> : never;
export type { Prettify } from 'viem/chains';
