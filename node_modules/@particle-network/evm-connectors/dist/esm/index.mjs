// src/coinbaseWallet.ts
import {
  ChainNotConfiguredError,
  SwitchChainError,
  UserRejectedRequestError,
  createConnector,
  numberToHex
} from "@particle-network/connector-core";
coinbaseWallet.type = "coinbaseWallet";
function coinbaseWallet(parameters = {}) {
  let sdk;
  let walletProvider;
  let accountsChanged;
  let chainChanged;
  let disconnect;
  return createConnector((config) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    type: coinbaseWallet.type,
    async connect({ chainId } = {}) {
      try {
        const provider = await this.getProvider();
        const accounts = await provider.request({
          method: "eth_requestAccounts"
        });
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = chain?.id ?? currentChainId;
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
      provider.disconnect();
      provider.close?.();
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return await provider.request({
        method: "eth_accounts"
      });
    },
    async getChainId() {
      const provider = await this.getProvider();
      const chainId = await provider.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      if (!walletProvider) {
        const { default: CoinbaseSDK_ } = await import("@coinbase/wallet-sdk");
        const CoinbaseSDK = (() => {
          if (typeof CoinbaseSDK_ !== "function" && typeof CoinbaseSDK_.default === "function")
            return CoinbaseSDK_.default;
          return CoinbaseSDK_;
        })();
        sdk = new CoinbaseSDK({
          ...parameters,
          appChainIds: config.chains.map((x) => x.id)
        });
        walletProvider = sdk.makeWeb3Provider({
          ...parameters,
          options: parameters.preference ?? "all"
        });
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const chain = config.chains.find((chain2) => chain2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider = await this.getProvider();
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chain.id) }]
        });
        return chain;
      } catch (error) {
        if (error.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter?.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = chain.blockExplorers?.default.url ? [chain.blockExplorers?.default.url] : [];
            let rpcUrls;
            if (addEthereumChainParameter?.rpcUrls?.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [chain.rpcUrls.default?.http[0] ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: addEthereumChainParameter?.chainName ?? chain.name,
              iconUrls: addEthereumChainParameter?.iconUrls,
              nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config.emitter.emit("change", {
          accounts
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
    },
    isInstalled() {
      return true;
    }
  }));
}

// src/injected.ts
import {
  ChainNotConfiguredError as ChainNotConfiguredError2,
  ProviderNotFoundError,
  SwitchChainError as SwitchChainError2,
  UserRejectedRequestError as UserRejectedRequestError2,
  createConnector as createConnector2,
  numberToHex as numberToHex2
} from "@particle-network/connector-core";
import { ResourceUnavailableRpcError, withRetry, withTimeout } from "viem";
var targetMap = {
  coinbaseWallet: {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    provider(window2) {
      if (window2?.coinbaseWalletExtension)
        return window2.coinbaseWalletExtension;
      return findProvider(window2, "isCoinbaseWallet");
    }
  },
  metaMask: {
    id: "metaMask",
    name: "MetaMask",
    provider(window2) {
      return findProvider(window2, (provider) => {
        if (!provider.isMetaMask)
          return false;
        if (provider.isBraveWallet && !provider._events && !provider._state)
          return false;
        const flags = [
          "isApexWallet",
          "isAvalanche",
          "isBitKeep",
          "isBlockWallet",
          "isKuCoinWallet",
          "isMathWallet",
          "isOkxWallet",
          "isOKExWallet",
          "isOneInchIOSWallet",
          "isOneInchAndroidWallet",
          "isOpera",
          "isPortal",
          "isRabby",
          "isTokenPocket",
          "isTokenary",
          "isZerion"
        ];
        for (const flag of flags)
          if (provider[flag])
            return false;
        return true;
      });
    }
  },
  phantom: {
    id: "phantom",
    name: "Phantom",
    provider(window2) {
      if (window2?.phantom?.ethereum)
        return window2.phantom?.ethereum;
      return findProvider(window2, "isPhantom");
    }
  },
  safePal: {
    id: "safePal",
    name: "SafePal",
    provider(window2) {
      return window2?.safepalProvider;
    }
  },
  coin98: {
    id: "coin98",
    name: "Coin98 Wallet",
    provider(window2) {
      if (window2?.coin98?.provider)
        return window2.coin98?.provider;
      return findProvider(window2, "isCoin98");
    }
  },
  onekey: {
    id: "onekey",
    name: "OneKey",
    provider(window2) {
      return window2?.$onekey?.ethereum;
    }
  },
  bybitWallet: {
    id: "bybitWallet",
    name: "Bybit Wallet",
    provider(window2) {
      return window2?.bybitWallet;
    }
  },
  braveWallet: {
    id: "braveWallet",
    name: "Brave Wallet",
    provider(window2) {
      return window2?.braveEthereum;
    }
  }
};
injected.type = "injected";
function injected(parameters = {}) {
  const { shimDisconnect = true, unstableShimAsyncInject } = parameters;
  function getTarget() {
    const target = parameters.target;
    if (typeof target === "function") {
      const result = target();
      if (result)
        return result;
    }
    if (typeof target === "object")
      return target;
    if (typeof target === "string")
      return {
        ...targetMap[target] ?? {
          id: target,
          name: `${target[0].toUpperCase()}${target.slice(1)}`,
          provider: `is${target[0].toUpperCase()}${target.slice(1)}`
        }
      };
    return {
      id: "injected",
      name: "Injected",
      provider(window2) {
        return window2?.ethereum;
      }
    };
  }
  let accountsChanged;
  let chainChanged;
  let connect;
  let disconnect;
  return createConnector2((config) => ({
    get icon() {
      return getTarget().icon;
    },
    get id() {
      return getTarget().id;
    },
    get name() {
      return getTarget().name;
    },
    type: injected.type,
    async setup() {
      const provider = await this.getProvider();
      if (provider && parameters.target) {
        if (!connect) {
          connect = this.onConnect.bind(this);
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
      }
    },
    async connect({ chainId, isReconnecting } = {}) {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      let accounts = [];
      if (isReconnecting) {
        accounts = await this.getAccounts().catch(() => []);
      } else if (shimDisconnect) {
        try {
          const permissions = await provider.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }]
          });
          accounts = permissions[0]?.caveats?.[0]?.value;
          if (accounts?.length) {
            const sortedAccounts = await this.getAccounts();
            accounts = sortedAccounts;
          }
        } catch (err) {
          const error = err;
          if (error.code === UserRejectedRequestError2.code)
            throw new UserRejectedRequestError2(error);
          if (error.code === ResourceUnavailableRpcError.code)
            throw error;
        }
      }
      try {
        if (!accounts?.length && !isReconnecting) {
          const requestedAccounts = await provider.request({
            method: "eth_requestAccounts"
          });
          accounts = requestedAccounts;
        }
        if (connect) {
          provider.removeListener("connect", connect);
          connect = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError2.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = chain?.id ?? currentChainId;
        }
        if (shimDisconnect)
          await config.storage?.removeItem(`${this.id}.disconnected`);
        if (!parameters.target)
          await config.storage?.setItem("injected.connected", true);
        return { accounts, chainId: currentChainId };
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError2.code)
          throw new UserRejectedRequestError2(error);
        if (error.code === ResourceUnavailableRpcError.code)
          throw new ResourceUnavailableRpcError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
      if (!connect) {
        connect = this.onConnect.bind(this);
      }
      try {
        await provider.request({
          method: "wallet_revokePermissions",
          params: [{ eth_accounts: {} }]
        });
      } catch (e) {
      }
      if (shimDisconnect) {
        await config.storage?.setItem(`${this.id}.disconnected`, true);
      }
      if (!parameters.target)
        await config.storage?.removeItem("injected.connected");
    },
    async getAccounts() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const accounts = await provider.request({ method: "eth_accounts" });
      return accounts;
    },
    async getChainId() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const hexChainId = await provider.request({ method: "eth_chainId" });
      return Number(hexChainId);
    },
    async getProvider() {
      if (typeof window === "undefined")
        return void 0;
      let provider;
      const target = getTarget();
      if (typeof target.provider === "function")
        provider = target.provider(window);
      else if (typeof target.provider === "string")
        provider = findProvider(window, target.provider);
      else
        provider = target.provider;
      if (provider && !provider.removeListener) {
        if ("off" in provider && typeof provider.off === "function")
          provider.removeListener = provider.off;
        else
          provider.removeListener = () => {
          };
      }
      return provider;
    },
    async isAuthorized() {
      try {
        const isDisconnected = shimDisconnect && await config.storage?.getItem(`${this.id}.disconnected`);
        if (isDisconnected)
          return false;
        if (!parameters.target) {
          const connected = await config.storage?.getItem("injected.connected");
          if (!connected)
            return false;
        }
        const provider = await this.getProvider();
        if (!provider) {
          if (unstableShimAsyncInject !== void 0 && unstableShimAsyncInject !== false) {
            const handleEthereum = async () => {
              if (typeof window !== "undefined")
                window.removeEventListener("ethereum#initialized", handleEthereum);
              const provider2 = await this.getProvider();
              return !!provider2;
            };
            const timeout = typeof unstableShimAsyncInject === "number" ? unstableShimAsyncInject : 1e3;
            const res = await Promise.race([
              ...typeof window !== "undefined" ? [
                new Promise(
                  (resolve) => window.addEventListener("ethereum#initialized", () => resolve(handleEthereum()), { once: true })
                )
              ] : [],
              new Promise((resolve) => setTimeout(() => resolve(handleEthereum()), timeout))
            ]);
            if (res)
              return true;
          }
          throw new ProviderNotFoundError();
        }
        const accounts = await withRetry(
          () => withTimeout(() => this.getAccounts(), {
            timeout: 100
          })
        );
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const chain = config.chains.find((x) => x.id === chainId);
      if (!chain)
        throw new SwitchChainError2(new ChainNotConfiguredError2());
      try {
        await Promise.all([
          provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex2(chainId) }]
          }).then(async () => {
            const currentChainId = await this.getChainId();
            if (currentChainId === chainId)
              config.emitter.emit("change", { chainId });
          }),
          new Promise(
            (resolve) => config.emitter.once("change", ({ chainId: currentChainId }) => {
              if (currentChainId === chainId)
                resolve();
            })
          )
        ]);
        return chain;
      } catch (err) {
        const error = err;
        if (error.code === 4902 || error?.data?.originalError?.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter?.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = chain.blockExplorers?.default.url ? [chain.blockExplorers?.default.url] : [];
            let rpcUrls;
            if (addEthereumChainParameter?.rpcUrls?.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [chain.rpcUrls.default?.http[0] ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex2(chainId),
              chainName: addEthereumChainParameter?.chainName ?? chain.name,
              iconUrls: addEthereumChainParameter?.iconUrls,
              nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            const currentChainId = await this.getChainId();
            if (currentChainId !== chainId)
              throw new UserRejectedRequestError2(new Error("User rejected switch after adding network."));
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError2(error2);
          }
        }
        if (error.code === UserRejectedRequestError2.code)
          throw new UserRejectedRequestError2(error);
        throw new SwitchChainError2(error);
      }
    },
    async onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else if (config.emitter.listenerCount("connect")) {
        const chainId = (await this.getChainId()).toString();
        this.onConnect({ chainId });
        if (shimDisconnect)
          await config.storage?.removeItem(`${this.id}.disconnected`);
      } else
        config.emitter.emit("change", {
          accounts
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const accounts = await this.getAccounts();
      if (accounts.length === 0)
        return;
      const chainId = Number(connectInfo.chainId);
      config.emitter.emit("connect", { accounts, chainId });
      const provider = await this.getProvider();
      if (provider) {
        if (connect) {
          provider.removeListener("connect", connect);
          connect = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect);
        }
      }
    },
    async onDisconnect(error) {
      const provider = await this.getProvider();
      if (error && error.code === 1013) {
        if (provider && !!(await this.getAccounts()).length)
          return;
      }
      config.emitter.emit("disconnect");
      if (provider) {
        if (chainChanged) {
          provider.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect) {
          provider.removeListener("disconnect", disconnect);
          disconnect = void 0;
        }
        if (!connect) {
          connect = this.onConnect.bind(this);
        }
      }
    },
    isInstalled() {
      if (typeof window === "undefined")
        return false;
      let provider;
      const target = getTarget();
      if (typeof target.provider === "function")
        provider = target.provider(window);
      else if (typeof target.provider === "string")
        provider = findProvider(window, target.provider);
      else
        provider = target.provider;
      return Boolean(provider);
    }
  }));
}
function findProvider(window2, select) {
  function isProvider(provider) {
    if (typeof select === "function")
      return select(provider);
    if (typeof select === "string")
      return provider[select];
    return true;
  }
  const ethereum = window2.ethereum;
  if (ethereum?.providers)
    return ethereum.providers.find((provider) => isProvider(provider));
  if (ethereum && isProvider(ethereum))
    return ethereum;
  return void 0;
}

// src/passkeySmartWallet.ts
import {
  ChainNotConfiguredError as ChainNotConfiguredError3,
  ProviderNotFoundError as ProviderNotFoundError2,
  SwitchChainError as SwitchChainError3,
  UserRejectedRequestError as UserRejectedRequestError4,
  createConnector as createConnector3,
  numberToHex as numberToHex3
} from "@particle-network/connector-core";

// src/provider/passkeyProvider.ts
import { ConnectorNotConnectedError, UserRejectedRequestError as UserRejectedRequestError3 } from "@particle-network/connector-core";
import Base64url2 from "crypto-js/enc-base64url";
import Hex2 from "crypto-js/enc-hex";
import Utf82 from "crypto-js/enc-utf8";
import { EventEmitter } from "eventemitter3";
import { InvalidParamsRpcError, encodeAbiParameters, isHex, parseAbiParameters, toHex } from "viem";

// src/utils/passkeys.ts
import { uid } from "@particle-network/connector-core";
import { ECDSASigValue } from "@peculiar/asn1-ecc";
import { AsnParser } from "@peculiar/asn1-schema";
import { startAuthentication, startRegistration } from "@simplewebauthn/browser";
import Base64url from "crypto-js/enc-base64url";
import Hex from "crypto-js/enc-hex";
import Utf8 from "crypto-js/enc-utf8";
import SHA256 from "crypto-js/sha256";
import { toBytes } from "viem";

// src/utils/index.ts
var formatDate = (date) => {
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  return `${year}/${month}/${day}`;
};

// src/utils/passkeys.ts
var passkeysRegistration = async (name) => {
  const expiration = Math.floor(new Date().getTime() / 1e3 + 300);
  const challenge = Base64url.stringify(
    Utf8.parse(`${SHA256(`${location.origin}:${expiration}`).toString()}:${expiration}`)
  );
  const id = uid();
  const displayName = name || `Particle Smart Wallet ${formatDate(new Date())}`;
  const options = {
    challenge,
    rp: { name: "Particle Smart Wallet", id: location.hostname },
    user: {
      id,
      name: displayName,
      displayName
    },
    pubKeyCredParams: [
      { alg: -7, type: "public-key" }
    ],
    timeout: 6e4,
    attestation: "none",
    excludeCredentials: [],
    authenticatorSelection: {
      residentKey: "preferred",
      userVerification: "required",
      requireResidentKey: false
    },
    extensions: { credProps: true }
  };
  const result = await startRegistration(options);
  return result;
};
var passkeysAuthentication = async (option) => {
  const { credentialId, challenge } = option || {};
  const expiration = Math.floor(new Date().getTime() / 1e3 + 300);
  const challengeValue = challenge || Base64url.stringify(Utf8.parse(`${SHA256(`${location.origin}:${expiration}`).toString()}:${expiration}`));
  const options = {
    challenge: challengeValue,
    allowCredentials: credentialId ? [
      {
        type: "public-key",
        id: credentialId
      }
    ] : void 0,
    timeout: 6e4,
    userVerification: "required",
    extensions: void 0,
    rpId: location.hostname
  };
  const result = await startAuthentication(options);
  return result;
};
var ellipticZZPoints = BigInt("0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
function getMessageSign(signature) {
  const hexSignature = Hex.stringify(Base64url.parse(signature));
  const parsedSignature = AsnParser.parse(toBytes(`0x${hexSignature}`), ECDSASigValue);
  let rBytes = new Uint8Array(parsedSignature.r);
  let sBytes = new Uint8Array(parsedSignature.s);
  if (shouldRemoveLeadingZero(rBytes)) {
    rBytes = rBytes.slice(1);
  }
  if (shouldRemoveLeadingZero(sBytes)) {
    sBytes = sBytes.slice(1);
  }
  const r = BigInt("0x" + Buffer.from(rBytes).toString("hex"));
  let s = BigInt("0x" + Buffer.from(sBytes).toString("hex"));
  if (s > ellipticZZPoints / 2n) {
    s = ellipticZZPoints - s;
  }
  return [r, s];
}
function shouldRemoveLeadingZero(bytes) {
  if (!bytes.length) {
    return false;
  }
  return bytes[0] === 0 && (bytes[1] & 1 << 7) !== 0;
}
function isPasskeySupported() {
  if (typeof window === "undefined" || !navigator.credentials || typeof navigator.credentials.create !== "function") {
    return false;
  }
  if (typeof window.PublicKeyCredential !== "function") {
    return false;
  }
  return true;
}

// src/provider/passkeyProvider.ts
var defaultAddress = "0x0000000000000000000000000000000000000000";
var PasskeyProvider = class {
  #emitter;
  #storage;
  isPasskey = true;
  constructor({ storage }) {
    this.#emitter = new EventEmitter();
    this.#storage = storage;
  }
  on(event, fn) {
    this.#emitter.on(event, fn);
    return this;
  }
  removeListener(event, fn) {
    this.#emitter.removeListener(event, fn);
    return this;
  }
  async request(payload) {
    if (payload.method === "eth_accounts") {
      const option = await this.getPasskeyOption();
      if (option) {
        return [defaultAddress];
      }
      return [];
    } else if (payload.method === "eth_requestAccounts") {
      const option = await this.getPasskeyOption();
      if (option) {
        return [defaultAddress];
      }
      const isRegistering = payload.params?.[0];
      if (isRegistering) {
        const result = await passkeysRegistration(payload.params?.[1]);
        await this.#storage.setItem("passkey.options", {
          credentialId: result.rawId,
          publicKey: result.response.publicKey
        });
      } else {
        const result = await passkeysAuthentication();
        await this.#storage.setItem("passkey.options", {
          credentialId: result.rawId
        });
      }
      return [defaultAddress];
    } else if (payload.method === "eth_chainId") {
      const chainId = await this.#storage.getItem("passkey.chainId");
      if (chainId) {
        return `0x${chainId.toString(16)}`;
      }
      return "0x1";
    } else if (payload.method === "wallet_switchEthereumChain") {
      const chainId = payload.params?.[0]?.chainId;
      if (!chainId) {
        throw new InvalidParamsRpcError(new Error("chainId not found."));
      }
      await this.#storage.setItem("passkey.chainId", Number(chainId));
      setTimeout(() => this.#emitter.emit("chainChanged", chainId), 0);
      return;
    } else if (payload.method === "personal_sign") {
      const message = payload.params?.[0];
      if (!message) {
        throw new InvalidParamsRpcError(new Error("message not found."));
      }
      const signature = await this.signMessage(message);
      return signature;
    }
    throw new Error(`The Passkey Provider does not support this method: ${payload.method}`);
  }
  async getPasskeyOption() {
    const option = await this.#storage.getItem("passkey.options");
    return option;
  }
  async signMessage(message) {
    const option = await this.getPasskeyOption();
    if (!option) {
      throw new ConnectorNotConnectedError();
    }
    let unsignMessage = message;
    if (!isHex(message)) {
      unsignMessage = toHex(message);
    }
    const challenge = Base64url2.stringify(Hex2.parse(unsignMessage.slice(2)));
    let result;
    try {
      result = await passkeysAuthentication({
        credentialId: option.credentialId,
        challenge
      });
    } catch (error) {
      if (error.name === "NotAllowedError") {
        throw new UserRejectedRequestError3(error);
      }
      throw error;
    }
    const rawSignature = result.response.signature;
    const authenticatorData = result.response.authenticatorData;
    const clientDataJSON = result.response.clientDataJSON;
    const [r, s] = getMessageSign(rawSignature);
    const clientDataJSONString = Utf82.stringify(Base64url2.parse(clientDataJSON));
    const challengePos = clientDataJSONString.indexOf("challenge") - 1;
    const typePos = clientDataJSONString.indexOf("type") - 1;
    const authData = Hex2.stringify(Base64url2.parse(authenticatorData));
    const signature = encodeAbiParameters(
      parseAbiParameters(
        "(bytes authenticatorData, string clientDataJSON, uint256 challengeIndex, uint256 typeIndex, uint256 r, uint256 s)"
      ),
      [[`0x${authData}`, clientDataJSONString, BigInt(challengePos), BigInt(typePos), r, s]]
    );
    return signature;
  }
};

// src/passkeySmartWallet.ts
passkeySmartWallet.type = "passkeySmartWallet";
function passkeySmartWallet(parameters = {}) {
  let walletProvider;
  let chainChanged;
  const { registrationName } = parameters;
  let isUserVerifyingPlatformAuthenticatorAvailable;
  if (isPasskeySupported()) {
    window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable().then((v) => {
      isUserVerifyingPlatformAuthenticatorAvailable = v;
    }).catch(() => {
      isUserVerifyingPlatformAuthenticatorAvailable = false;
    });
  }
  return createConnector3((config) => ({
    id: "passkeySmartWallet",
    name: "Passkey Smart Wallet",
    type: passkeySmartWallet.type,
    async connect({ chainId, isReconnecting, isRegistering = true } = {}) {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError2();
      let accounts = [];
      if (isReconnecting) {
        accounts = await this.getAccounts().catch(() => []);
      }
      try {
        if (!accounts?.length && !isReconnecting) {
          const name = isRegistering ? registrationName?.() : void 0;
          const requestedAccounts = await provider.request({
            method: "eth_requestAccounts",
            params: [isRegistering, name]
          });
          accounts = requestedAccounts;
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch(() => {
            return { id: currentChainId };
          });
          currentChainId = chain?.id ?? currentChainId;
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (error.name === "NotAllowedError") {
          throw new UserRejectedRequestError4(error);
        }
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      await config.storage?.removeItem("passkey.options");
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
    },
    async getAccounts() {
      const provider = await this.getProvider();
      const accounts = await provider.request({
        method: "eth_accounts"
      });
      return accounts;
    },
    async getChainId() {
      const provider = await this.getProvider();
      const chainId = await provider.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      if (!walletProvider) {
        walletProvider = new PasskeyProvider({ storage: config.storage });
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ chainId }) {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError2();
      const chain = config.chains.find((x) => x.id === chainId);
      if (!chain)
        throw new SwitchChainError3(new ChainNotConfiguredError3());
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: numberToHex3(chainId) }]
      });
      return chain;
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config.emitter.emit("disconnect");
    },
    isInstalled() {
      return isUserVerifyingPlatformAuthenticatorAvailable ?? isPasskeySupported();
    },
    async getPasskeyOption() {
      const provider = await this.getProvider();
      return provider.getPasskeyOption();
    }
  }));
}

// src/walletConnect.ts
import {
  ChainNotConfiguredError as ChainNotConfiguredError4,
  ProviderNotFoundError as ProviderNotFoundError3,
  SwitchChainError as SwitchChainError4,
  UserRejectedRequestError as UserRejectedRequestError5,
  createConnector as createConnector4,
  numberToHex as numberToHex4
} from "@particle-network/connector-core";
var defaultProjectId = "673a283fa38457f23911103771ccc65d";
walletConnect.type = "walletConnect";
function walletConnect(parameters) {
  const isNewChainsStale = parameters.isNewChainsStale ?? true;
  let provider_;
  let providerPromise;
  const NAMESPACE = "eip155";
  let accountsChanged;
  let chainChanged;
  let connect;
  let displayUri;
  let sessionDelete;
  let disconnect;
  return createConnector4((config) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: walletConnect.type,
    projectId: config["walletConnectProjectId"] || parameters.projectId || defaultProjectId,
    async setup() {
      const provider = await this.getProvider().catch(() => null);
      if (!provider)
        return;
      if (!connect) {
        connect = this.onConnect.bind(this);
        provider.on("connect", connect);
      }
      if (!sessionDelete) {
        sessionDelete = this.onSessionDelete.bind(this);
        provider.on("session_delete", sessionDelete);
      }
    },
    async connect({ chainId, ...rest }) {
      try {
        const provider = await this.getProvider();
        if (!provider)
          throw new ProviderNotFoundError3();
        if (!displayUri) {
          displayUri = this.onDisplayUri;
          provider.on("display_uri", displayUri);
        }
        let targetChainId = chainId;
        if (!targetChainId) {
          const state = await config.storage?.getItem("state") ?? {};
          const isChainSupported = config.chains.some((x) => x.id === state.chainId);
          if (isChainSupported)
            targetChainId = state.chainId;
          else
            targetChainId = config.chains[0]?.id;
        }
        if (!targetChainId)
          throw new Error("No chains found on connector.");
        const isChainsStale = await this.isChainsStale();
        if (provider.session && isChainsStale)
          await provider.disconnect();
        if (!provider.session || isChainsStale) {
          const optionalChains = config.chains.filter((chain) => chain.id !== targetChainId).map((optionalChain) => optionalChain.id);
          await provider.connect({
            optionalChains: [targetChainId, ...optionalChains],
            ..."pairingTopic" in rest ? { pairingTopic: rest.pairingTopic } : {}
          });
          this.setRequestedChainsIds(config.chains.map((x) => x.id));
        }
        const accounts = await provider.enable();
        const currentChainId = await this.getChainId();
        if (displayUri) {
          provider.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (connect) {
          provider.removeListener("connect", connect);
          connect = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect);
        }
        if (!sessionDelete) {
          sessionDelete = this.onSessionDelete.bind(this);
          provider.on("session_delete", sessionDelete);
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user rejected|connection request reset)/i.test(error?.message)) {
          throw new UserRejectedRequestError5(error);
        }
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      try {
        await provider?.disconnect();
      } catch (error) {
        if (!/No matching key/i.test(error.message))
          throw error;
      } finally {
        if (chainChanged) {
          provider?.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect) {
          provider?.removeListener("disconnect", disconnect);
          disconnect = void 0;
        }
        if (!connect) {
          connect = this.onConnect.bind(this);
          provider?.on("connect", connect);
        }
        if (accountsChanged) {
          provider?.removeListener("accountsChanged", accountsChanged);
          accountsChanged = void 0;
        }
        if (sessionDelete) {
          provider?.removeListener("session_delete", sessionDelete);
          sessionDelete = void 0;
        }
        this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return provider.accounts;
    },
    async getProvider({ chainId } = {}) {
      const pId = this.projectId;
      async function initProvider() {
        const optionalChains = config.chains.map((x) => x.id);
        if (!optionalChains.length)
          return;
        const { EthereumProvider } = await import("@walletconnect/ethereum-provider");
        return await EthereumProvider.init({
          ...parameters,
          disableProviderPing: true,
          optionalChains,
          projectId: pId,
          rpcMap: Object.fromEntries(config.chains.map((chain) => [chain.id, chain.rpcUrls.default.http[0]])),
          showQrModal: parameters.showQrModal ?? false
        });
      }
      if (!provider_) {
        if (!providerPromise)
          providerPromise = initProvider();
        provider_ = await providerPromise;
        provider_?.events.setMaxListeners(Number.POSITIVE_INFINITY);
      }
      if (chainId)
        await this.switchChain?.({ chainId });
      return provider_;
    },
    async getChainId() {
      const provider = await this.getProvider();
      return provider.chainId;
    },
    async isAuthorized() {
      try {
        const [accounts, provider] = await Promise.all([this.getAccounts(), this.getProvider()]);
        if (!accounts.length)
          return false;
        const isChainsStale = await this.isChainsStale();
        if (isChainsStale && provider.session) {
          await provider.disconnect().catch(() => {
          });
          return false;
        }
        return true;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const currentChainId = await this.getChainId();
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError3();
      const chain = config.chains.find((x) => x.id === chainId);
      if (!chain)
        throw new SwitchChainError4(new ChainNotConfiguredError4());
      if (currentChainId === chainId) {
        return chain;
      }
      try {
        await Promise.all([
          new Promise((resolve) => {
            const listener = ({ chainId: currentChainId2 }) => {
              if (currentChainId2 === chainId) {
                config.emitter.off("change", listener);
                resolve();
              }
            };
            config.emitter.on("change", listener);
          }),
          provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex4(chainId) }]
          })
        ]);
        const requestedChains = await this.getRequestedChainsIds();
        this.setRequestedChainsIds([...requestedChains, chainId]);
        return chain;
      } catch (err) {
        const error = err;
        if (/(user rejected)/i.test(error.message))
          throw new UserRejectedRequestError5(error);
        try {
          let blockExplorerUrls;
          if (addEthereumChainParameter?.blockExplorerUrls)
            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
          else
            blockExplorerUrls = chain.blockExplorers?.default.url ? [chain.blockExplorers?.default.url] : [];
          let rpcUrls;
          if (addEthereumChainParameter?.rpcUrls?.length)
            rpcUrls = addEthereumChainParameter.rpcUrls;
          else
            rpcUrls = [chain.rpcUrls.default?.http[0] ?? ""];
          const addEthereumChain = {
            blockExplorerUrls,
            chainId: numberToHex4(chainId),
            chainName: addEthereumChainParameter?.chainName ?? chain.name,
            iconUrls: addEthereumChainParameter?.iconUrls,
            nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,
            rpcUrls
          };
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [addEthereumChain]
          });
          const requestedChains = await this.getRequestedChainsIds();
          this.setRequestedChainsIds([...requestedChains, chainId]);
          return chain;
        } catch (error2) {
          throw new UserRejectedRequestError5(error2);
        }
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config.emitter.emit("change", {
          accounts
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const chainId = Number(connectInfo.chainId);
      const accounts = await this.getAccounts();
      config.emitter.emit("connect", { accounts, chainId });
    },
    async onDisconnect(_error) {
      this.setRequestedChainsIds([]);
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
      if (sessionDelete) {
        provider.removeListener("session_delete", sessionDelete);
        sessionDelete = void 0;
      }
      if (!connect) {
        connect = this.onConnect.bind(this);
        provider.on("connect", connect);
      }
    },
    onDisplayUri(uri) {
      config.emitter.emit("message", { type: "display_uri", data: uri });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      if (!provider_)
        return [];
      const chainIds = provider_.session?.namespaces[NAMESPACE]?.accounts?.map(
        (account) => Number.parseInt(account.split(":")[1] || "")
      );
      return chainIds ?? [];
    },
    async getRequestedChainsIds() {
      return await config.storage?.getItem(this.requestedChainsStorageKey) ?? [];
    },
    async isChainsStale() {
      if (!isNewChainsStale)
        return false;
      const connectorChains = config.chains.map((x) => x.id);
      const namespaceChains = this.getNamespaceChainsIds();
      if (namespaceChains.length && !namespaceChains.some((id) => connectorChains.includes(id)))
        return false;
      const requestedChains = await this.getRequestedChainsIds();
      return !connectorChains.every((id) => requestedChains.includes(id));
    },
    async setRequestedChainsIds(chains) {
      await config.storage?.setItem(this.requestedChainsStorageKey, chains);
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  }));
}

// src/defaultConnectorFns.ts
var defaultConnectorFns = ({
  metadata,
  walletConnectProjectId
} = {}) => {
  const hasAllAppData = metadata && metadata.name && metadata.icon && metadata.description && metadata.url;
  const connectors = [];
  connectors.push(injected({ target: "metaMask" }));
  connectors.push(injected({ target: "trustWallet" }));
  connectors.push(injected({ target: "bitKeep" }));
  connectors.push(injected({ target: "okxWallet" }));
  connectors.push(injected({ target: "phantom" }));
  if (metadata) {
    connectors.push(
      coinbaseWallet({
        appName: metadata.name,
        appLogoUrl: metadata.icon
      })
    );
  }
  connectors.push(
    walletConnect({
      showQrModal: false,
      projectId: walletConnectProjectId,
      metadata: hasAllAppData ? {
        name: metadata.name,
        description: metadata.description,
        url: metadata.url,
        icons: [metadata.icon]
      } : void 0
    })
  );
  return connectors;
};

// src/store.ts
import {
  ChainNotConfiguredError as ChainNotConfiguredError5,
  createEmitter,
  createWalletConnector,
  isEVMChain
} from "@particle-network/connector-core";
import { createStore as createMipd } from "mipd";
import { createStore } from "zustand/vanilla";

// src/getPublicClient.ts
import { createPublicClient, http } from "viem";
var clients = /* @__PURE__ */ new Map();
function getPublicClient(chain) {
  {
    const client2 = clients.get(chain.id);
    if (client2)
      return client2;
  }
  const client = createPublicClient({
    chain,
    transport: http()
  });
  clients.set(chain.id, client);
  return client;
}

// src/store.ts
evmWalletConnectors.type = "evmWallet";
function evmWalletConnectors(parameters = {}) {
  const { metadata, walletConnectProjectId, connectorFns, multiInjectedProviderDiscovery = true } = parameters;
  const defaultConnectorFns2 = connectorFns ?? defaultConnectorFns({
    metadata,
    walletConnectProjectId
  });
  return createWalletConnector((options) => {
    const { ...rest } = options;
    const allChains = rest.chains.filter(isEVMChain);
    if (allChains.length == 0) {
      throw new Error("Please add EVM chains in Connectkit options.");
    }
    const mipd = typeof window !== "undefined" && multiInjectedProviderDiscovery ? createMipd() : void 0;
    const chains = createStore(() => allChains);
    let wcProjectId = null;
    function providerDetailToConnector(providerDetail) {
      const { info } = providerDetail;
      const provider = providerDetail.provider;
      return injected({ target: { ...info, id: info.rdns, provider } });
    }
    function setup(connectorFn) {
      const emitter = createEmitter();
      const config = { emitter, chains: chains.getState(), storage: rest.storage, walletConnectProjectId };
      const connector = {
        ...connectorFn(config),
        emitter,
        uid: emitter.uid,
        chainType: "evm",
        walletConnectorType: evmWalletConnectors.type
      };
      connector.setup?.();
      if (connector.type === "walletConnect") {
        wcProjectId = connector["projectId"];
      }
      return connector;
    }
    const registeredProvider = mipd?.getProviders().filter((details) => details.info.rdns !== "network.particle").map(providerDetailToConnector) ?? [];
    const connectors = createStore(() => [...defaultConnectorFns2, ...registeredProvider].map(setup));
    let _w3mConnector;
    if (wcProjectId) {
      const hasAllAppData = metadata && metadata.name && metadata.icon && metadata.description && metadata.url;
      _w3mConnector = walletConnect({
        showQrModal: true,
        projectId: wcProjectId,
        metadata: hasAllAppData ? {
          name: metadata.name,
          description: metadata.description,
          url: metadata.url,
          icons: [metadata.icon]
        } : void 0
      });
    }
    mipd?.subscribe((providerDetails) => {
      const currentConnectorIds = /* @__PURE__ */ new Map();
      for (const connector of connectors.getState()) {
        currentConnectorIds.set(connector.id, true);
      }
      const newConnectors = [];
      for (const providerDetail of providerDetails) {
        if (providerDetail.info.rdns === "network.particle") {
          continue;
        }
        const connector = setup(providerDetailToConnector(providerDetail));
        if (currentConnectorIds.has(connector.id))
          continue;
        newConnectors.push(connector);
      }
      if (newConnectors.length) {
        connectors.setState((x) => [...x, ...newConnectors], true);
      }
    });
    function getClient(chainId) {
      const chain = chains.getState().find((chain2) => chain2.id === chainId);
      if (!chain) {
        throw new ChainNotConfiguredError5();
      }
      return getPublicClient(chain);
    }
    return {
      get type() {
        return evmWalletConnectors.type;
      },
      get chains() {
        return chains.getState();
      },
      get connectors() {
        return connectors.getState();
      },
      store: connectors,
      getClient,
      w3mConnector: _w3mConnector,
      _internal: {
        connectors: {
          setup
        }
      }
    };
  });
}

// src/version.ts
var version = "1.0.8";
export {
  coinbaseWallet,
  defaultConnectorFns,
  evmWalletConnectors,
  injected,
  passkeySmartWallet,
  version,
  walletConnect
};
//# sourceMappingURL=index.mjs.map
