{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/injected.ts", "../../src/utils.ts", "../../src/defaultConnectorFns.ts", "../../src/store.ts", "../../src/getConnection.ts", "../../src/version.ts"],
  "sourcesContent": ["export * from './defaultConnectorFns';\nexport * from './injected';\nexport * from './store';\nexport * from './version';\n", "import {\n  ChainNotConfiguredError,\n  ProviderNotFoundError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  WalletAccountError,\n  createConnector,\n  type Connector,\n  type Evaluate,\n  type Prettify,\n  type RpcError,\n  type SolanaProvider,\n} from '@particle-network/connector-core';\nimport { PublicKey } from '@solana/web3.js';\nimport { isConnected } from './utils';\n\ntype Target = {\n  icon?: string;\n  id: string;\n  name: string;\n  provider: (window?: Window | undefined) => SolanaProvider | undefined;\n};\n\ntype TargetId = 'coinbaseWallet' | 'bitKeep' | 'trustWallet' | 'okxWallet' | 'phantom' | 'braveWallet';\n\ntype TargetMap = { [_ in TargetId]: Target };\n\nexport type InjectedParameters = {\n  unstableShimAsyncInject?: boolean | number | undefined;\n  target: TargetId | Target | (() => Target);\n};\n\ntype Window = {\n  coinbaseSolana?: any | undefined;\n  bitkeep?: any | undefined;\n  phantom?: any | undefined;\n  trustwallet?: any | undefined;\n  okxwallet?: any | undefined;\n  braveSolana?: any | undefined;\n};\n\nconst targetMap = {\n  coinbaseWallet: {\n    id: 'coinbaseWallet',\n    name: 'Coinbase Wallet',\n    provider(window) {\n      if (typeof window !== 'undefined') {\n        return window?.coinbaseSolana;\n      }\n      return undefined;\n    },\n  },\n  bitKeep: {\n    id: 'bitKeep',\n    name: 'Bitget',\n    provider(window) {\n      if (typeof window !== 'undefined' && window.bitkeep?.solana?.isBitKeep) {\n        return window.bitkeep?.solana;\n      }\n    },\n  },\n  phantom: {\n    id: 'phantom',\n    name: 'Phantom',\n    provider(window) {\n      if (typeof window !== 'undefined' && window.phantom?.solana?.isPhantom) {\n        return window.phantom?.solana;\n      }\n    },\n  },\n  trustWallet: {\n    id: 'trustWallet',\n    name: 'Trust Wallet',\n    provider(window) {\n      if (typeof window !== 'undefined' && window.trustwallet?.solana?.isTrust) {\n        return window.trustwallet?.solana;\n      }\n    },\n  },\n  okxWallet: {\n    id: 'okxWallet',\n    name: 'OKX Wallet',\n    provider(window) {\n      if (typeof window !== 'undefined' && window.okxwallet?.solana?.isOkxWallet) {\n        return window.okxwallet?.solana;\n      }\n    },\n  },\n  braveWallet: {\n    id: 'braveWallet',\n    name: 'Brave Wallet',\n    provider(window) {\n      if (typeof window !== 'undefined' && window.braveSolana?.isBraveWallet) {\n        return window.braveSolana;\n      }\n    },\n  },\n} as const satisfies TargetMap;\n\ninjected.type = 'injected' as const;\nexport function injected(parameters: InjectedParameters) {\n  const { unstableShimAsyncInject } = parameters;\n\n  function getTarget(): Evaluate<Target & { id: string }> {\n    const target = parameters.target;\n    if (typeof target === 'function') {\n      const result = target();\n      if (result) return result;\n    }\n\n    if (typeof target === 'object') return target;\n\n    if (typeof target === 'string' && targetMap[target as keyof typeof targetMap])\n      return targetMap[target as keyof typeof targetMap];\n\n    throw new Error('target not found.');\n  }\n\n  type Provider = SolanaProvider | undefined;\n  type Properties = {\n    publicKey?: PublicKey;\n    onAccountChanged(publicKey: PublicKey): void;\n  };\n  type StorageItem = Prettify<\n    {\n      [_ in `${string}.injected.connected`]: true;\n    } & {\n      [_ in `${string}.injected.chainId`]: number;\n    }\n  >;\n\n  let accountChanged: Properties['onAccountChanged'] | undefined;\n  let disconnect: Connector['onDisconnect'] | undefined;\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    get icon() {\n      return getTarget().icon;\n    },\n    get id() {\n      return `solana_${getTarget().id}`;\n    },\n    get name() {\n      return getTarget().name;\n    },\n    type: injected.type,\n    async connect({ chainId, isReconnecting } = {}) {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      let accounts: readonly string[] = [];\n      if (isReconnecting) {\n        const connected = await config.storage?.getItem(`${this.id}.injected.connected`);\n        if (connected) {\n          if (!isConnected(provider)) {\n            await provider.connect();\n          }\n          if (!provider.publicKey) throw new WalletAccountError(this.id);\n        }\n        accounts = await this.getAccounts().catch(() => []);\n      }\n\n      try {\n        if (!accounts?.length && !isReconnecting) {\n          if (!isConnected(provider)) {\n            await provider.connect();\n          }\n\n          if (!provider.publicKey) throw new WalletAccountError(this.id);\n          accounts = [provider.publicKey.toBase58()];\n        }\n\n        if (!accountChanged) {\n          accountChanged = this.onAccountChanged.bind(this);\n          provider.on('accountChanged', accountChanged);\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this);\n          provider.on('disconnect', disconnect);\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId();\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error;\n            return { id: currentChainId };\n          });\n          currentChainId = chain?.id ?? currentChainId;\n        }\n\n        // Add connected shim\n        await config.storage?.setItem(`${this.id}.injected.connected`, true);\n\n        if (provider.publicKey) {\n          this.publicKey = new PublicKey(provider.publicKey.toBytes());\n        }\n\n        return { accounts, chainId: currentChainId };\n      } catch (err) {\n        const error = err as RpcError;\n        if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n        throw error;\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect);\n        disconnect = undefined;\n      }\n\n      try {\n        await provider.disconnect();\n      } catch {\n        // ignore\n      }\n\n      await config.storage?.removeItem(`${this.id}.injected.connected`);\n      this.publicKey = undefined;\n    },\n    async getAccounts() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      if (this.publicKey) {\n        return [this.publicKey.toBase58()];\n      }\n\n      const connected = await config.storage?.getItem(`${this.id}.injected.connected`);\n      if (connected) {\n        if (!isConnected(provider)) {\n          await provider.connect();\n        }\n        if (provider.publicKey) {\n          this.publicKey = new PublicKey(provider.publicKey.toBytes());\n          return [this.publicKey.toBase58()];\n        }\n      }\n\n      return [];\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n\n      const chainId = await config.storage?.getItem(`${this.id}.injected.chainId`);\n      if (chainId && config.chains.find((chain) => chain.id === Number(chainId))) {\n        return Number(chainId);\n      }\n      return config.chains[0].id;\n    },\n    async getProvider() {\n      if (typeof window === 'undefined') return undefined;\n\n      const target = getTarget();\n      const provider: Provider = target.provider(window as Window);\n      return provider;\n    },\n    async isAuthorized() {\n      try {\n        let provider = await this.getProvider();\n        if (!provider) {\n          if (unstableShimAsyncInject !== undefined && unstableShimAsyncInject !== false) {\n            const handleProvider = async () => {\n              const provider = await this.getProvider();\n              return provider;\n            };\n            const timeout = typeof unstableShimAsyncInject === 'number' ? unstableShimAsyncInject : 1_000;\n            provider = await new Promise<Provider>((resolve) => setTimeout(() => resolve(handleProvider()), timeout));\n            if (!provider) {\n              throw new ProviderNotFoundError();\n            }\n          } else {\n            throw new ProviderNotFoundError();\n          }\n        }\n\n        const connected = await config.storage?.getItem(`${this.id}.injected.connected`);\n        return Boolean(connected);\n      } catch {\n        return false;\n      }\n    },\n    async switchChain({ chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId);\n      if (!chain) {\n        throw new SwitchChainError(new ChainNotConfiguredError());\n      }\n      await config.storage?.setItem(`${this.id}.injected.chainId`, chainId);\n      config.emitter.emit('change', { chainId });\n      return chain;\n    },\n    async onAccountChanged(publicKey) {\n      if (!publicKey) {\n        this.publicKey = undefined;\n        // Disconnect if there are no accounts\n        this.onDisconnect();\n      } else {\n        this.publicKey = new PublicKey(publicKey.toBytes());\n        config.emitter.emit('change', {\n          accounts: [this.publicKey.toBase58()],\n        });\n      }\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', { chainId });\n    },\n    async onDisconnect() {\n      const provider = await this.getProvider();\n      config.emitter.emit('disconnect');\n      if (provider) {\n        if (disconnect) {\n          provider.removeListener('disconnect', disconnect);\n          disconnect = undefined;\n        }\n      }\n      this.publicKey = undefined;\n      await config.storage?.removeItem(`${this.id}.injected.connected`);\n    },\n    isInstalled(): boolean {\n      if (typeof window === 'undefined') return false;\n\n      const target = getTarget();\n      const provider = target.provider(window as Window);\n      return Boolean(provider);\n    },\n  }));\n}\n", "import type { SolanaProvider } from '@particle-network/connector-core';\n\nexport const isConnected = (provider: SolanaProvider) => {\n  // some provider not defined `isConnected`, such as Trust Wallet.\n  if (provider && typeof provider.isConnected === 'boolean') {\n    return provider.isConnected;\n  }\n\n  return Boolean(provider?.publicKey);\n};\n", "import type { CreateConnectorFn } from '@particle-network/connector-core';\nimport { injected } from './injected';\n\nexport const defaultConnectorFns = (): CreateConnectorFn[] => {\n  const connectors: CreateConnectorFn[] = [];\n\n  connectors.push(injected({ target: 'phantom' }));\n  connectors.push(injected({ target: 'coinbaseWallet' }));\n  connectors.push(injected({ target: 'okxWallet' }));\n  connectors.push(injected({ target: 'bitKeep' }));\n  connectors.push(injected({ target: 'trustWallet' }));\n\n  return connectors;\n};\n", "import {\n  ChainNotConfiguredError,\n  createEmitter,\n  createWalletConnector,\n  isSolanaChain,\n  type ChainType,\n  type ClientType,\n  type Connector,\n  type ConnectorEventMap,\n  type CreateConnectorFn,\n  type SolanaChain,\n  type WalletConnectorsOption,\n} from '@particle-network/connector-core';\nimport type { Chain } from 'viem/chains';\nimport { createStore } from 'zustand/vanilla';\nimport { defaultConnectorFns as defaultSolanaConnectorFns } from './defaultConnectorFns';\nimport { getConnection } from './getConnection';\n\ntype ConnectorsOption = WalletConnectorsOption;\n\nexport type WalletParameters = {\n  connectorFns?: CreateConnectorFn[];\n};\n\nsolanaWalletConnectors.type = 'solanaWallet' as const;\nexport function solanaWalletConnectors(parameters: WalletParameters = {}) {\n  const { connectorFns } = parameters;\n  const defaultConnectorFns = connectorFns ?? defaultSolanaConnectorFns();\n\n  return createWalletConnector<ConnectorsOption>((options) => {\n    const { ...rest } = options;\n\n    const allChains = rest.chains.filter(isSolanaChain) as [Chain, ...Chain[]];\n    if (allChains.length == 0) {\n      throw new Error('Please add Solana chains in Connectkit options.');\n    }\n    const chains = createStore(() => allChains);\n\n    function setup(connectorFn: CreateConnectorFn): Connector {\n      // Set up emitter and add to connector so they are \"linked\" together.\n      const emitter = createEmitter<ConnectorEventMap>();\n      const connector = {\n        ...connectorFn({ emitter, chains: chains.getState(), storage: rest.storage }),\n        emitter,\n        uid: emitter.uid,\n        chainType: 'solana' as const,\n        walletConnectorType: solanaWalletConnectors.type,\n      };\n\n      connector.setup?.();\n      return connector;\n    }\n\n    const connectors = createStore(() => [...defaultConnectorFns].map(setup));\n\n    function getClient<chainType extends ChainType = SolanaChain>(chainId: number): ClientType<chainType> {\n      const chain = chains.getState().find((chain) => chain.id === chainId);\n      if (!chain) {\n        throw new ChainNotConfiguredError();\n      }\n      return getConnection(chain) as ClientType<chainType>;\n    }\n\n    return {\n      get type() {\n        return solanaWalletConnectors.type;\n      },\n      get chains() {\n        return chains.getState();\n      },\n      get connectors() {\n        return connectors.getState();\n      },\n      store: connectors,\n      getClient,\n      _internal: {\n        connectors: {\n          setup,\n        },\n      },\n    };\n  });\n}\n", "import { Connection } from '@solana/web3.js';\nimport type { Chain } from 'viem/chains';\n\nconst clients = new Map<number, Connection>();\n\nexport function getConnection(chain: Chain): Connection {\n  {\n    const client = clients.get(chain.id);\n    if (client) return client;\n  }\n\n  const client = new Connection(chain.rpcUrls.default.http[0]!);\n\n  clients.set(chain.id, client);\n\n  return client;\n}\n", "export const version = '1.0.1';\n"],
  "mappings": "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",
  "names": ["window", "provider", "chain", "import_connector_core", "import_web3", "client", "defaultConnectorFns", "chain"]
}
