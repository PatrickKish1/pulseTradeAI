{
  "version": 3,
  "sources": ["../../src/createConnector.ts", "../../src/createEmitter.ts", "../../src/utils/uid.ts", "../../src/utils/deserialize.ts", "../../src/utils/serialize.ts", "../../src/createStorage.ts", "../../src/version.ts", "../../src/errors/base.ts", "../../src/errors/config.ts", "../../src/errors/connector.ts", "../../src/errors/rpc.ts", "../../src/utils/solana.ts", "../../src/utils/index.ts"],
  "sourcesContent": ["import type { Connection } from '@solana/web3.js';\nimport type { Chain, PublicClient } from 'viem';\nimport type { StoreApi } from 'zustand/vanilla';\nimport type { Connector, WalletConnectorType } from './baseConnector';\nimport type { ChainType, EVMChain } from './chains/types';\nimport type { Emitter } from './createEmitter';\nimport type { Storage } from './createStorage';\nimport type { Evaluate, ExactPartial } from './types/utils';\n\nexport type AddEthereumChainParameter = {\n  /** A 0x-prefixed hexadecimal string */\n  chainId: string;\n  /** The chain name. */\n  chainName: string;\n  /** Native currency for the chain. */\n  nativeCurrency?:\n    | {\n        name: string;\n        symbol: string;\n        decimals: number;\n      }\n    | undefined;\n  rpcUrls: readonly string[];\n  blockExplorerUrls?: string[] | undefined;\n  iconUrls?: string[] | undefined;\n};\n\nexport type ProviderConnectInfo = {\n  chainId: string;\n};\n\nexport type ProviderMessage = {\n  type: string;\n  data: unknown;\n};\n\nexport type ConnectorEventMap = {\n  change: {\n    accounts?: readonly string[] | undefined;\n    chainId?: number | undefined;\n  };\n  connect: { accounts: readonly string[]; chainId: number };\n  disconnect: never;\n  error: { error: Error };\n  message: { type: string; data?: unknown | undefined };\n};\n\nexport type CreateConnectorFn<\n  provider = unknown,\n  properties extends Record<string, unknown> = Record<string, unknown>,\n  storageItem extends Record<string, unknown> = Record<string, unknown>,\n> = (config: {\n  chains: readonly [Chain, ...Chain[]];\n  emitter: Emitter<ConnectorEventMap>;\n  storage?: Evaluate<Storage<storageItem>> | null | undefined;\n}) => Evaluate<\n  {\n    readonly icon?: string | undefined;\n    readonly id: string;\n    readonly name: string;\n    readonly type: string;\n\n    setup?(): Promise<void>;\n    connect(parameters?: { chainId?: number | undefined; isReconnecting?: boolean | undefined } | undefined): Promise<{\n      accounts: readonly string[];\n      chainId: number;\n    }>;\n    disconnect(): Promise<void>;\n    getAccounts(): Promise<readonly string[]>;\n    getChainId(): Promise<number>;\n    getProvider(parameters?: { chainId?: number | undefined } | undefined): Promise<provider>;\n    isAuthorized(): Promise<boolean>;\n    switchChain?(\n      parameters: Evaluate<{\n        addEthereumChainParameter?: ExactPartial<Omit<AddEthereumChainParameter, 'chainId'>> | undefined;\n        chainId: number;\n      }>\n    ): Promise<Chain>;\n\n    onAccountsChanged?(accounts: string[]): void;\n    onChainChanged(chainId: string): void;\n    onConnect?(connectInfo: ProviderConnectInfo): void;\n    onDisconnect(error?: Error | undefined): void;\n    onMessage?(message: ProviderMessage): void;\n    isInstalled?(): boolean;\n  } & properties\n>;\n\nexport type ClientType<chainType extends ChainType = EVMChain> = chainType extends EVMChain ? PublicClient : Connection;\n\nexport function createConnector<\n  provider,\n  properties extends Record<string, unknown> = Record<string, unknown>,\n  storageItem extends Record<string, unknown> = Record<string, unknown>,\n>(createConnectorFn: CreateConnectorFn<provider, properties, storageItem>) {\n  return createConnectorFn;\n}\n\nexport type WalletConnectorsOption = {\n  chains: readonly [Chain, ...Chain[]];\n  storage: Storage;\n};\n\nexport type CreateWalletConnectorFn<\n  option extends WalletConnectorsOption = WalletConnectorsOption,\n  properties extends Record<string, unknown> = Record<string, unknown>,\n> = (parameters: option) => Evaluate<\n  {\n    readonly type: WalletConnectorType;\n    readonly chains: readonly [Chain, ...Chain[]];\n    readonly connectors: Connector[];\n    store: StoreApi<Connector[]>;\n    _internal: {\n      connectors: {\n        setup: (connectorFn: CreateConnectorFn) => Connector;\n      };\n    };\n    getClient<chainType extends ChainType = EVMChain>(chainId: number): ClientType<chainType>;\n  } & properties\n>;\n\nexport function createWalletConnector<\n  option extends WalletConnectorsOption = WalletConnectorsOption,\n  properties extends Record<string, unknown> = Record<string, unknown>,\n>(createWalletConnectorFn: CreateWalletConnectorFn<option, properties>) {\n  return createWalletConnectorFn as CreateWalletConnectorFn;\n}\n\nexport type WalletConnector<properties extends Record<string, unknown> = Record<string, unknown>> = ReturnType<\n  CreateWalletConnectorFn<any, properties>\n>;\n", "import { EventEmitter } from 'eventemitter3';\nimport { uid } from './utils/uid';\n\ntype EventMap = Record<string, object | never>;\ntype EventKey<eventMap extends EventMap> = string & keyof eventMap;\ntype EventFn<parameters extends unknown[] = any[]> = (...parameters: parameters) => void;\nexport type EventData<eventMap extends EventMap, eventName extends keyof eventMap> = (eventMap[eventName] extends [\n  never,\n]\n  ? unknown\n  : eventMap[eventName]) & {\n  uid: string;\n};\n\nexport class Emitter<eventMap extends EventMap> {\n  _emitter = new EventEmitter();\n\n  constructor(public uid: string) {}\n\n  on<key extends EventKey<eventMap>>(\n    eventName: key,\n    fn: EventFn<eventMap[key] extends [never] ? [{ uid: string }] : [data: eventMap[key] & { uid: string }]>\n  ) {\n    this._emitter.on(eventName, fn as EventFn);\n  }\n\n  once<key extends EventKey<eventMap>>(\n    eventName: key,\n    fn: EventFn<eventMap[key] extends [never] ? [{ uid: string }] : [data: eventMap[key] & { uid: string }]>\n  ) {\n    this._emitter.once(eventName, fn as EventFn);\n  }\n\n  off<key extends EventKey<eventMap>>(\n    eventName: key,\n    fn: EventFn<eventMap[key] extends [never] ? [{ uid: string }] : [data: eventMap[key] & { uid: string }]>\n  ) {\n    this._emitter.off(eventName, fn as EventFn);\n  }\n\n  emit<key extends EventKey<eventMap>>(\n    eventName: key,\n    ...params: eventMap[key] extends [never] ? [] : [data: eventMap[key]]\n  ) {\n    const data = params[0];\n    this._emitter.emit(eventName, { uid: this.uid, ...data });\n  }\n\n  listenerCount<key extends EventKey<eventMap>>(eventName: key) {\n    return this._emitter.listenerCount(eventName);\n  }\n}\n\nexport function createEmitter<eventMap extends EventMap>() {\n  return new Emitter<eventMap>(uid());\n}\n", "const size = 256;\nlet index = size;\nlet buffer: string;\n\nexport function uid(length = 11) {\n  if (!buffer || index + length > size * 2) {\n    buffer = '';\n    index = 0;\n    for (let i = 0; i < size; i++) {\n      buffer += ((256 + Math.random() * 256) | 0).toString(16).substring(1);\n    }\n  }\n  return buffer.substring(index, index++ + length);\n}\n", "type Reviver = (key: string, value: any) => any;\n\nexport function deserialize<type>(value: string, reviver?: Reviver): type {\n  return JSON.parse(value, (key, value_) => {\n    let value = value_;\n    if (value?.__type === 'bigint') value = BigInt(value.value);\n    if (value?.__type === 'Map') value = new Map(value.value);\n    return reviver?.(key, value) ?? value;\n  });\n}\n", "/**\n * Get the reference key for the circular value\n *\n * @param keys the keys to build the reference key from\n * @param cutoff the maximum number of keys to include\n * @returns the reference key\n */\nfunction getReferenceKey(keys: string[], cutoff: number) {\n  return keys.slice(0, cutoff).join('.') || '.';\n}\n\n/**\n * Faster `Array.prototype.indexOf` implementation build for slicing / splicing\n *\n * @param array the array to match the value in\n * @param value the value to match\n * @returns the matching index, or -1\n */\nfunction getCutoff(array: any[], value: any) {\n  const { length } = array;\n\n  for (let index = 0; index < length; ++index) {\n    if (array[index] === value) {\n      return index + 1;\n    }\n  }\n\n  return 0;\n}\n\ntype StandardReplacer = (key: string, value: any) => any;\ntype CircularReplacer = (key: string, value: any, referenceKey: string) => any;\n\n/**\n * Create a replacer method that handles circular values\n *\n * @param [replacer] a custom replacer to use for non-circular values\n * @param [circularReplacer] a custom replacer to use for circular methods\n * @returns the value to stringify\n */\nfunction createReplacer(\n  replacer?: StandardReplacer | null | undefined,\n  circularReplacer?: CircularReplacer | null | undefined\n): StandardReplacer {\n  const hasReplacer = typeof replacer === 'function';\n  const hasCircularReplacer = typeof circularReplacer === 'function';\n\n  const cache: any[] = [];\n  const keys: string[] = [];\n\n  return function replace(this: any, key: string, value: any) {\n    if (typeof value === 'object') {\n      if (cache.length) {\n        const thisCutoff = getCutoff(cache, this);\n\n        if (thisCutoff === 0) {\n          cache[cache.length] = this;\n        } else {\n          cache.splice(thisCutoff);\n          keys.splice(thisCutoff);\n        }\n\n        keys[keys.length] = key;\n\n        const valueCutoff = getCutoff(cache, value);\n\n        if (valueCutoff !== 0) {\n          return hasCircularReplacer\n            ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff))\n            : `[ref=${getReferenceKey(keys, valueCutoff)}]`;\n        }\n      } else {\n        cache[0] = value;\n        keys[0] = key;\n      }\n    }\n\n    return hasReplacer ? replacer.call(this, key, value) : value;\n  };\n}\n\n/**\n * Stringifier that handles circular values\n *\n * Forked from https://github.com/planttheidea/fast-stringify\n *\n * @param value to stringify\n * @param [replacer] a custom replacer function for handling standard values\n * @param [indent] the number of spaces to indent the output by\n * @param [circularReplacer] a custom replacer function for handling circular values\n * @returns the stringified output\n */\nexport function serialize(\n  value: any,\n  replacer?: StandardReplacer | null | undefined,\n  indent?: number | null | undefined,\n  circularReplacer?: CircularReplacer | null | undefined\n) {\n  return JSON.stringify(\n    value,\n    createReplacer((key, value_) => {\n      let value = value_;\n      if (typeof value === 'bigint') value = { __type: 'bigint', value: value_.toString() };\n      if (value instanceof Map) value = { __type: 'Map', value: Array.from(value_.entries()) };\n      return replacer?.(key, value) ?? value;\n    }, circularReplacer),\n    indent ?? undefined\n  );\n}\n", "import type { PartializedState } from './baseConnector';\nimport type { Evaluate } from './types/utils';\nimport { deserialize as deserialize_ } from './utils/deserialize';\nimport { serialize as serialize_ } from './utils/serialize';\n\n// key-values for loose autocomplete and typing\nexport type StorageItemMap = {\n  recentConnectorId: string;\n  state: PartializedState;\n};\n\nexport type Storage<\n  itemMap extends Record<string, unknown> = Record<string, unknown>,\n  ///\n  storageItemMap extends StorageItemMap = StorageItemMap & itemMap,\n> = {\n  key: string;\n  getItem<\n    key extends keyof storageItemMap,\n    value extends storageItemMap[key],\n    defaultValue extends value | null | undefined,\n  >(\n    key: key,\n    defaultValue?: defaultValue | undefined\n  ): (defaultValue extends null ? value | null : value) | Promise<defaultValue extends null ? value | null : value>;\n  setItem<key extends keyof storageItemMap, value extends storageItemMap[key] | null>(\n    key: key,\n    value: value\n  ): void | Promise<void>;\n  removeItem(key: keyof storageItemMap): void | Promise<void>;\n};\n\nexport type BaseStorage = {\n  getItem(key: string): string | null | undefined | Promise<string | null | undefined>;\n  setItem(key: string, value: string): void | Promise<void>;\n  removeItem(key: string): void | Promise<void>;\n};\n\nexport type CreateStorageParameters = {\n  deserialize?: (<T>(value: string) => T) | undefined;\n  key?: string | undefined;\n  serialize?: (<T>(value: T) => string) | undefined;\n  storage?: Evaluate<BaseStorage> | undefined;\n};\n\nexport function createStorage<\n  itemMap extends Record<string, unknown> = Record<string, unknown>,\n  storageItemMap extends StorageItemMap = StorageItemMap & itemMap,\n>(parameters: CreateStorageParameters): Evaluate<Storage<storageItemMap>> {\n  const {\n    deserialize = deserialize_,\n    key: prefix = 'particle-connectkit',\n    serialize = serialize_,\n    storage = noopStorage,\n  } = parameters;\n\n  function unwrap<type>(value: type): type | Promise<type> {\n    if (value instanceof Promise) return value.then((x) => x).catch(() => null);\n    return value;\n  }\n\n  return {\n    ...storage,\n    key: prefix,\n    async getItem(key, defaultValue) {\n      const value = storage.getItem(`${prefix}.${key as string}`);\n      const unwrapped = await unwrap(value);\n      if (unwrapped) return deserialize(unwrapped) ?? null;\n      return (defaultValue ?? null) as any;\n    },\n    async setItem(key, value) {\n      const storageKey = `${prefix}.${key as string}`;\n      if (value === null) await unwrap(storage.removeItem(storageKey));\n      else await unwrap(storage.setItem(storageKey, serialize(value)));\n    },\n    async removeItem(key) {\n      await unwrap(storage.removeItem(`${prefix}.${key as string}`));\n    },\n  };\n}\n\nexport const noopStorage = {\n  getItem: () => null,\n  setItem: () => {},\n  removeItem: () => {},\n} satisfies BaseStorage;\n", "export const version = '1.0.1';\n", "import type { Evaluate, OneOf } from '../types/utils';\nimport { version } from '../version';\n\nexport type ErrorType<name extends string = 'Error'> = Error & { name: name };\n\ntype BaseErrorOptions = Evaluate<\n  OneOf<{ details?: string | undefined } | { cause: BaseError | Error }> & {\n    metaMessages?: string[] | undefined;\n  }\n>;\n\nexport type BaseErrorType = BaseError & { name: 'ConnectorCoreError' };\nexport class BaseError extends Error {\n  details: string;\n  metaMessages?: string[] | undefined;\n  shortMessage: string;\n\n  override name = 'ConnectorCoreError';\n\n  get version() {\n    return version;\n  }\n\n  constructor(shortMessage: string, options: BaseErrorOptions = {}) {\n    super();\n\n    const details =\n      options.cause instanceof BaseError\n        ? options.cause.details\n        : options.cause?.message\n          ? options.cause.message\n          : options.details!;\n\n    this.message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(options.metaMessages ? [...options.metaMessages, ''] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      `Version: ${this.version}`,\n    ].join('\\n');\n\n    if (options.cause) this.cause = options.cause;\n    this.details = details;\n    this.metaMessages = options.metaMessages;\n    this.shortMessage = shortMessage;\n  }\n}\n", "import type { Connector } from '../baseConnector';\nimport { BaseError } from './base';\n\nexport type ChainNotConfiguredErrorType = ChainNotConfiguredError & {\n  name: 'ChainNotConfiguredError';\n};\n\nexport class ChainNotConfiguredError extends BaseError {\n  override name = 'ChainNotConfiguredError';\n  constructor() {\n    super('Chain not configured.');\n  }\n}\n\nexport type ConnectorAlreadyConnectedErrorType = ConnectorAlreadyConnectedError & {\n  name: 'ConnectorAlreadyConnectedError';\n};\n\nexport class ConnectorAlreadyConnectedError extends BaseError {\n  override name = 'ConnectorAlreadyConnectedError';\n  constructor() {\n    super('Connector already connected.');\n  }\n}\n\nexport type ConnectorNotConnectedErrorType = ConnectorNotConnectedError & {\n  name: 'ConnectorNotConnectedError';\n};\n\nexport class ConnectorNotConnectedError extends BaseError {\n  override name = 'ConnectorNotConnectedError';\n  constructor() {\n    super('Connector not connected.');\n  }\n}\n\nexport type ConnectorNotFoundErrorType = ConnectorNotFoundError & {\n  name: 'ConnectorNotFoundError';\n};\n\nexport class ConnectorNotFoundError extends BaseError {\n  override name = 'ConnectorNotFoundError';\n  constructor() {\n    super('Connector not found.');\n  }\n}\n\nexport type ConnectorAccountNotFoundErrorType = ConnectorAccountNotFoundError & {\n  name: 'ConnectorAccountNotFoundError';\n};\n\nexport class ConnectorAccountNotFoundError extends BaseError {\n  override name = 'ConnectorAccountNotFoundError';\n  constructor({ address, connector }: { address: string; connector: Connector }) {\n    super(`Account \"${address}\" not found for connector \"${connector.name}\".`);\n  }\n}\n", "import type { Connector } from '../baseConnector';\nimport { BaseError } from './base';\n\nexport type ProviderNotFoundErrorType = ProviderNotFoundError & {\n  name: 'ProviderNotFoundError';\n};\nexport class ProviderNotFoundError extends BaseError {\n  override name = 'ProviderNotFoundError';\n  constructor() {\n    super('Provider not found.');\n  }\n}\n\nexport type SwitchChainNotSupportedErrorType = SwitchChainNotSupportedError & {\n  name: 'SwitchChainNotSupportedError';\n};\nexport class SwitchChainNotSupportedError extends BaseError {\n  override name = 'SwitchChainNotSupportedError';\n\n  constructor({ connector }: { connector: Connector }) {\n    super(`\"${connector.name}\" does not support programmatic chain switching.`);\n  }\n}\n\nexport class WalletAccountError extends BaseError {\n  override name = 'WalletAccountError';\n  constructor(id: string) {\n    super(`\"${id}\" wallet account error.`);\n  }\n}\n\nexport class ChainTypeError extends BaseError {\n  override name = 'ChainTypeError';\n  constructor() {\n    super('Chain Type Error.');\n  }\n}\n", "import type { Prettify } from 'viem/chains';\nimport { BaseError } from './base';\n\nconst unknownErrorCode = -1;\n\nexport type RpcErrorCode =\n  | -1\n  | -32700 // Parse error\n  | -32600 // Invalid request\n  | -32601 // Method not found\n  | -32602 // Invalid params\n  | -32603 // Internal error\n  | -32000 // Invalid input\n  | -32001 // Resource not found\n  | -32002 // Resource unavailable\n  | -32003 // Transaction rejected\n  | -32004 // Method not supported\n  | -32005 // Limit exceeded\n  | -32006 // JSON-RPC version not supported\n  | -32042; // Method not found\n\nexport type ProviderRpcErrorCode =\n  | 4001 // User Rejected Request\n  | 4100 // Unauthorized\n  | 4200 // Unsupported Method\n  | 4900 // Disconnected\n  | 4901 // Chain Disconnected\n  | 4902; // Chain Not Recognized\n\ntype RpcErrorOptions<TCode extends number = RpcErrorCode> = {\n  code?: TCode | undefined;\n  docsPath?: string | undefined;\n  metaMessages?: string[] | undefined;\n  shortMessage: string;\n};\n\nexport class RpcError<TCode extends number = RpcErrorCode> extends BaseError {\n  override name = 'RpcError';\n\n  code: TCode | number;\n\n  constructor(cause: Error, { code, metaMessages, shortMessage }: RpcErrorOptions<TCode>) {\n    super(shortMessage, {\n      cause,\n      metaMessages: metaMessages || (cause as { metaMessages?: string[] })?.metaMessages,\n    });\n    this.name = cause.name;\n    this.code = ((cause as any).code || code || unknownErrorCode) as TCode;\n  }\n}\n\nexport class ProviderRpcError<T = undefined> extends RpcError<ProviderRpcErrorCode> {\n  override name = 'ProviderRpcError';\n\n  data?: T | undefined;\n\n  constructor(\n    cause: Error,\n    options: Prettify<\n      RpcErrorOptions<ProviderRpcErrorCode> & {\n        data?: T | undefined;\n      }\n    >\n  ) {\n    super(cause, options);\n\n    this.data = options.data;\n  }\n}\n\nexport type UserRejectedRequestErrorType = UserRejectedRequestError & {\n  code: 4001;\n  name: 'UserRejectedRequestError';\n};\nexport class UserRejectedRequestError extends ProviderRpcError {\n  override name = 'UserRejectedRequestError';\n  static code = 4001 as const;\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UserRejectedRequestError.code,\n      shortMessage: 'User rejected the request.',\n    });\n  }\n}\n\n/**\n * Subclass for an \"Unauthorized\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type UnauthorizedProviderErrorType = UnauthorizedProviderError & {\n  code: 4100;\n  name: 'UnauthorizedProviderError';\n};\nexport class UnauthorizedProviderError extends ProviderRpcError {\n  override name = 'UnauthorizedProviderError';\n  static code = 4100 as const;\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UnauthorizedProviderError.code,\n      shortMessage: 'The requested method and/or account has not been authorized by the user.',\n    });\n  }\n}\n\n/**\n * Subclass for an \"Unsupported Method\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type UnsupportedProviderMethodErrorType = UnsupportedProviderMethodError & {\n  code: 4200;\n  name: 'UnsupportedProviderMethodError';\n};\nexport class UnsupportedProviderMethodError extends ProviderRpcError {\n  override name = 'UnsupportedProviderMethodError';\n  static code = 4200 as const;\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UnsupportedProviderMethodError.code,\n      shortMessage: 'The Provider does not support the requested method.',\n    });\n  }\n}\n\n/**\n * Subclass for an \"Disconnected\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type ProviderDisconnectedErrorType = ProviderDisconnectedError & {\n  code: 4900;\n  name: 'ProviderDisconnectedError';\n};\nexport class ProviderDisconnectedError extends ProviderRpcError {\n  override name = 'ProviderDisconnectedError';\n  static code = 4900 as const;\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ProviderDisconnectedError.code,\n      shortMessage: 'The Provider is disconnected from all chains.',\n    });\n  }\n}\n\n/**\n * Subclass for an \"Chain Disconnected\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type ChainDisconnectedErrorType = ChainDisconnectedError & {\n  code: 4901;\n  name: 'ChainDisconnectedError';\n};\nexport class ChainDisconnectedError extends ProviderRpcError {\n  override name = 'ChainDisconnectedError';\n  static code = 4901 as const;\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ChainDisconnectedError.code,\n      shortMessage: 'The Provider is not connected to the requested chain.',\n    });\n  }\n}\n\n/**\n * Subclass for an \"Switch Chain\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type SwitchChainErrorType = SwitchChainError & {\n  code: 4902;\n  name: 'SwitchChainError';\n};\nexport class SwitchChainError extends ProviderRpcError {\n  override name = 'SwitchChainError';\n  static code = 4902 as const;\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: SwitchChainError.code,\n      shortMessage: 'An error occurred when attempting to switch chain.',\n    });\n  }\n}\n\n/**\n * Subclass for an unknown RPC error.\n */\nexport type UnknownRpcErrorType = UnknownRpcError & {\n  name: 'UnknownRpcError';\n};\nexport class UnknownRpcError extends RpcError {\n  override name = 'UnknownRpcError';\n\n  constructor(cause: Error) {\n    super(cause, {\n      shortMessage: 'An unknown RPC error occurred.',\n    });\n  }\n}\n", "import type { Connection, SendOptions, Transaction, VersionedTransaction } from '@solana/web3.js';\nimport type { SolanaProvider } from '../types/solana';\n\nexport function isVersionedTransaction(\n  transaction: Transaction | VersionedTransaction\n): transaction is VersionedTransaction {\n  return 'version' in transaction;\n}\n\nexport const sendSolanaTransaction = async (\n  provider: SolanaProvider,\n  transaction: Transaction | VersionedTransaction,\n  connection: Connection,\n  options: SendOptions = {}\n) => {\n  if (!isVersionedTransaction(transaction)) {\n    transaction.feePayer = transaction.feePayer || provider.publicKey!;\n    transaction.recentBlockhash =\n      transaction.recentBlockhash ||\n      (\n        await connection.getLatestBlockhash({\n          commitment: options.preflightCommitment,\n          minContextSlot: options.minContextSlot,\n        })\n      ).blockhash;\n  }\n\n  options.preflightCommitment = options.preflightCommitment || connection.commitment;\n  const signedTx = await provider.signTransaction(transaction);\n  const signature = await connection.sendRawTransaction(signedTx.serialize(), options);\n  return { signature };\n};\n", "export * from './solana';\nexport * from './uid';\n\nexport const numberToHex = (value: number) => {\n  return `0x${value.toString(16)}`;\n};\n"],
  "mappings": "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",
  "names": ["uid", "value", "index", "value", "deserialize", "serialize"]
}
