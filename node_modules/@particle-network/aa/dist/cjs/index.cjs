"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // src/aaWrapProvider.ts
  var import_events = __toESM(__require("events"), 1);
  var SendTransactionMode = /* @__PURE__ */ ((SendTransactionMode2) => {
    SendTransactionMode2[SendTransactionMode2["UserSelect"] = 0] = "UserSelect";
    SendTransactionMode2[SendTransactionMode2["Gasless"] = 1] = "Gasless";
    SendTransactionMode2[SendTransactionMode2["UserPaidNative"] = 2] = "UserPaidNative";
    return SendTransactionMode2;
  })(SendTransactionMode || {});
  var SendTransactionEvent = /* @__PURE__ */ ((SendTransactionEvent2) => {
    SendTransactionEvent2["Request"] = "RequestSendTransaction";
    SendTransactionEvent2["Resolve"] = "ResolveSendTransaction";
    SendTransactionEvent2["Reject"] = "RejectSendTransaction";
    return SendTransactionEvent2;
  })(SendTransactionEvent || {});
  var AAWrapProvider = class {
    constructor(smartAccount, sendTxMode = 2 /* UserPaidNative */) {
      this.smartAccount = smartAccount;
      this.sendTxMode = sendTxMode;
      this.events = new import_events.default();
      this.events.setMaxListeners(100);
      if (!Object.values(SendTransactionMode).includes(sendTxMode)) {
        throw new Error(`sendTxMode value error, must in ${Object.values(SendTransactionMode)}`);
      }
    }
    resolveSendTransaction(params) {
      this.events.emit("ResolveSendTransaction" /* Resolve */, params);
    }
    rejectSendTransaction(error) {
      this.events.emit("RejectSendTransaction" /* Reject */, error);
    }
    on(event, listener) {
      if ("RequestSendTransaction" /* Request */ === event) {
        this.events.on(event, listener);
      } else {
        this.smartAccount.provider.on(event, listener);
      }
      return this;
    }
    once(event, listener) {
      if ("RequestSendTransaction" /* Request */ === event) {
        this.events.once(event, listener);
      } else {
        if (this.smartAccount.provider.once) {
          this.smartAccount.provider.once(event, listener);
        } else {
          this.smartAccount.provider.on(event, listener);
        }
      }
      return this;
    }
    off(event, listener) {
      var _a, _b;
      if ("RequestSendTransaction" /* Request */ === event) {
        this.events.off(event, listener);
      } else {
        if (this.smartAccount.provider.off) {
          this.smartAccount.provider.off(event, listener);
        } else {
          (_b = (_a = this.smartAccount.provider).removeListener) == null ? void 0 : _b.call(_a, event, listener);
        }
      }
      return this;
    }
    removeListener(event, listener) {
      var _a, _b;
      if ("RequestSendTransaction" /* Request */ === event) {
        this.events.removeListener(event, listener);
      } else {
        if (this.smartAccount.provider.removeListener) {
          this.smartAccount.provider.removeListener(event, listener);
        } else {
          (_b = (_a = this.smartAccount.provider).off) == null ? void 0 : _b.call(_a, event, listener);
        }
      }
      return this;
    }
    enable() {
      return this.request({
        method: "eth_requestAccounts"
      });
    }
    request(payload) {
      return __async(this, null, function* () {
        if (payload.method === "eth_requestAccounts" || payload.method === "eth_accounts") {
          yield this.smartAccount.provider.request(payload);
          const address = yield this.smartAccount.getAddress();
          return [address];
        } else if (payload.method === "eth_sendTransaction") {
          if (!payload.params) {
            return Promise.reject(new Error("send transaction param error"));
          }
          const txData = payload.params[0];
          const feeQuotesResult = yield this.smartAccount.getFeeQuotes(txData);
          if (this.sendTxMode === 1 /* Gasless */) {
            const { userOp, userOpHash } = feeQuotesResult.verifyingPaymasterGasless || feeQuotesResult.verifyingPaymasterNative;
            return this.smartAccount.sendUserOperation({ userOp, userOpHash });
          } else if (this.sendTxMode === 2 /* UserPaidNative */) {
            const { userOp, userOpHash } = feeQuotesResult.verifyingPaymasterNative;
            return this.smartAccount.sendUserOperation({ userOp, userOpHash });
          }
          return new Promise((resolve, reject) => {
            this.events.removeAllListeners("RejectSendTransaction" /* Reject */);
            this.events.removeAllListeners("ResolveSendTransaction" /* Resolve */);
            this.events.once("ResolveSendTransaction" /* Resolve */, (params) => __async(this, null, function* () {
              try {
                const sendParams = __spreadProps(__spreadValues({}, params), { tx: txData });
                const txHash = yield this.smartAccount.sendTransaction(sendParams);
                resolve(txHash);
              } catch (error) {
                reject(error);
              }
            }));
            this.events.once("RejectSendTransaction" /* Reject */, reject);
            if (!feeQuotesResult.transactions) {
              feeQuotesResult.transactions = [txData];
            }
            this.events.emit("RequestSendTransaction" /* Request */, feeQuotesResult);
          });
        }
        return this.smartAccount.provider.request(payload);
      });
    }
  };

  // src/smartAccount.ts
  var import_axios = __toESM(__require("axios"), 1);
  var import_viem = __require("viem");

  // src/utils.ts
  var rpcUrl = () => {
    const productionApi = "https://rpc.particle.network";
    const developmentApi = "https://rpc-debug.particle.network";
    const dev = typeof window !== "undefined" && window.__PARTICLE_ENVIRONMENT__ === "development";
    return dev ? developmentApi : productionApi;
  };
  function payloadId() {
    const date = Date.now() * Math.pow(10, 3);
    const extra = Math.floor(Math.random() * Math.pow(10, 3));
    return date + extra;
  }

  // src/smartAccount.ts
  var loadAccountPromise = /* @__PURE__ */ new Map();
  var SmartAccount = class {
    constructor(provider, config) {
      this.provider = provider;
      this.config = config;
      this.getChainId = () => __async(this, null, function* () {
        return yield this.provider.request({ method: "eth_chainId" });
      });
      this.getOwner = () => __async(this, null, function* () {
        const eoas = yield this.provider.request({ method: "eth_accounts" });
        return eoas[0];
      });
      this.signUserOpHash = (userOpHash) => __async(this, null, function* () {
        let message = userOpHash;
        if (this.provider.isPasskey && this.smartAccountContract.name !== "COINBASE") {
          message = (0, import_viem.hashMessage)({
            raw: userOpHash
          });
        }
        const eoa = yield this.getOwner();
        const signature = yield this.provider.request({
          method: "personal_sign",
          params: [message, eoa]
        });
        return signature;
      });
      var _a, _b;
      if (!this.config.projectId || !this.config.clientKey || !this.config.appId) {
        throw new Error("invalid project config");
      }
      if (!this.config.aaOptions.accountContracts) {
        throw new Error("invalid AA contract config");
      }
      const name = Object.keys(this.config.aaOptions.accountContracts)[0];
      const version = (_b = (_a = this.config.aaOptions.accountContracts[name]) == null ? void 0 : _a[0]) == null ? void 0 : _b.version;
      if (!name || !version) {
        throw new Error("invalid AA name or version");
      }
      this.smartAccountContract = {
        name,
        version
      };
      this.connection = import_axios.default.create({
        baseURL: `${rpcUrl()}/evm-chain`,
        timeout: 6e4
      });
      this.connection.interceptors.request.use((config2) => {
        var _a2, _b2, _c;
        if ((_a2 = config2 == null ? void 0 : config2.data) == null ? void 0 : _a2.method) {
          config2.baseURL = `${config2.baseURL}${((_b2 = config2.baseURL) == null ? void 0 : _b2.includes("?")) ? "&" : "?"}method=${(_c = config2 == null ? void 0 : config2.data) == null ? void 0 : _c.method}`;
        }
        return config2;
      });
    }
    setSmartAccountContract(contract) {
      const accountContract = this.config.aaOptions.accountContracts[contract.name];
      if (!accountContract || accountContract.length === 0 || accountContract.every((item) => item.version !== contract.version)) {
        throw new Error("Please configure the smart account contract first");
      }
      this.smartAccountContract = contract;
    }
    getAccountConfig() {
      return __async(this, null, function* () {
        var _a, _b;
        const accountContract = this.config.aaOptions.accountContracts[this.smartAccountContract.name];
        if (!accountContract || accountContract.every((item) => item.version !== this.smartAccountContract.version)) {
          throw new Error("Please configure the smart account contract first");
        }
        const ownerAddress = yield this.getOwner();
        let passkeyOption;
        if (this.provider.isPasskey) {
          passkeyOption = yield (_b = (_a = this.provider).getPasskeyOption) == null ? void 0 : _b.call(_a);
        }
        return {
          name: this.smartAccountContract.name,
          version: this.smartAccountContract.version,
          ownerAddress,
          options: passkeyOption ? {
            passkeyOption
          } : void 0
        };
      });
    }
    getFeeQuotes(tx) {
      return __async(this, null, function* () {
        const accountConfig = yield this.getAccountConfig();
        return this.sendRpc({
          method: "particle_aa_getFeeQuotes",
          params: [accountConfig, Array.isArray(tx) ? tx : [tx]]
        });
      });
    }
    buildUserOperation(_0) {
      return __async(this, arguments, function* ({ tx, feeQuote, tokenPaymasterAddress }) {
        const accountConfig = yield this.getAccountConfig();
        return yield this.sendRpc({
          method: "particle_aa_createUserOp",
          params: [accountConfig, Array.isArray(tx) ? tx : [tx], feeQuote, tokenPaymasterAddress].filter(
            (val) => !!val
          )
        });
      });
    }
    signUserOperation(_0) {
      return __async(this, arguments, function* ({ userOpHash, userOp }) {
        const signature = yield this.signUserOpHash(userOpHash);
        return __spreadProps(__spreadValues({}, userOp), { signature });
      });
    }
    sendUserOperation(_0) {
      return __async(this, arguments, function* ({ userOpHash, userOp }) {
        const signedUserOp = yield this.signUserOperation({ userOpHash, userOp });
        return this.sendSignedUserOperation(signedUserOp);
      });
    }
    sendSignedUserOperation(userOp, signerParams) {
      return __async(this, null, function* () {
        const accountConfig = yield this.getAccountConfig();
        return this.sendRpc({
          method: "particle_aa_sendUserOp",
          params: [accountConfig, userOp, signerParams]
        });
      });
    }
    sendTransaction(params) {
      return __async(this, null, function* () {
        if (Object.prototype.hasOwnProperty.call(params, "userOpHash") && Object.prototype.hasOwnProperty.call(params, "userOp")) {
          const { userOpHash, userOp } = params;
          if (userOpHash && userOp) {
            return this.sendUserOperation({ userOpHash, userOp });
          }
        }
        const { tx, feeQuote, tokenPaymasterAddress } = params;
        const userOpBundle = yield this.buildUserOperation({ tx, feeQuote, tokenPaymasterAddress });
        return this.sendUserOperation(userOpBundle);
      });
    }
    getAccount() {
      return __async(this, null, function* () {
        const accountConfig = yield this.getAccountConfig();
        const accounts = yield this.sendRpc({
          method: "particle_aa_getSmartAccount",
          params: [accountConfig]
        });
        return accounts[0];
      });
    }
    getAddress() {
      return __async(this, null, function* () {
        var _a, _b, _c;
        let suffix = yield this.getOwner();
        if (!suffix) {
          return "";
        }
        if (this.provider.isPasskey && suffix === "0x0000000000000000000000000000000000000000") {
          const credentialId = (_c = yield (_b = (_a = this.provider).getPasskeyOption) == null ? void 0 : _b.call(_a)) == null ? void 0 : _c.credentialId;
          if (credentialId) {
            suffix = credentialId;
          }
        }
        const accountConfig = yield this.getAccountConfig();
        const localKey = `particle_${accountConfig.name}_${accountConfig.version}_${suffix}`;
        if (typeof window !== "undefined" && localStorage) {
          const localAA = localStorage.getItem(localKey);
          if (localAA) {
            return localAA;
          }
        }
        const configKey = JSON.stringify(accountConfig);
        let accountPromise = loadAccountPromise.get(configKey);
        if (!accountPromise) {
          accountPromise = this.getAccount();
          loadAccountPromise.set(configKey, accountPromise);
        }
        try {
          const account = yield accountPromise;
          const address = account.smartAccountAddress;
          if (typeof window !== "undefined" && localStorage) {
            localStorage.setItem(localKey, address);
          }
          return address;
        } catch (error) {
          loadAccountPromise.delete(configKey);
          throw error;
        }
      });
    }
    isDeployed() {
      return __async(this, null, function* () {
        const account = yield this.getAccount();
        return account.isDeployed;
      });
    }
    deployWalletContract() {
      return __async(this, null, function* () {
        return this.sendTransaction({
          tx: {
            to: "0x0000000000000000000000000000000000000000",
            data: "0x"
          }
        });
      });
    }
    sendRpc(arg) {
      return __async(this, null, function* () {
        var _a;
        const chainId = Number(yield this.getChainId());
        const accountContract = this.config.aaOptions.accountContracts[this.smartAccountContract.name];
        const contractConfig = accountContract.find(
          (contract) => contract.version === this.smartAccountContract.version
        );
        if ((_a = contractConfig == null ? void 0 : contractConfig.chainIds) == null ? void 0 : _a.length) {
          if (!contractConfig.chainIds.includes(chainId)) {
            throw new Error(`Invalid Chain: ${chainId}`);
          }
        }
        const response = yield this.connection.post(
          "",
          __spreadProps(__spreadValues({}, arg), {
            id: payloadId(),
            jsonrpc: "2.0"
          }),
          {
            params: {
              chainId,
              projectUuid: this.config.projectId,
              projectKey: this.config.clientKey
            }
          }
        ).then((res) => res.data);
        if (response.error) {
          return Promise.reject(response.error);
        } else {
          return response.result;
        }
      });
    }
    createSessions(options) {
      return __async(this, null, function* () {
        const accountConfig = yield this.getAccountConfig();
        return yield this.sendRpc({
          method: "particle_aa_createSessions",
          params: [accountConfig, options]
        });
      });
    }
    validateSession(targetSession, sessions) {
      return __async(this, null, function* () {
        const accountConfig = yield this.getAccountConfig();
        return yield this.sendRpc({
          method: "particle_aa_validateSession",
          params: [
            accountConfig,
            {
              sessions,
              targetSession
            }
          ]
        });
      });
    }
  };
})();
//# sourceMappingURL=index.cjs.map
